[{"categories":["数据库"],"content":"{% blockquote 黑马程序员 https://www.bilibili.com/video/BV1Kr4y1i7ru/?share_source=copy_web\u0026vd_source=e43c1de8e41e1499f7f3fdb03fba0eb6 黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括 %} {% endblockquote %} 在此非常感谢两位热爱学习的小伙伴的鼎力相助，帮助我们完成了所有的章节内容，使得本篇超长笔记得以完结。至此，整个MySQL笔记从入门到高级的所有内容都已编写完毕。 特别感谢： wlh (wen-lh) - Gitee.com B站同学： @守心-人 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#"},{"categories":["数据库"],"content":" 基础篇","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基础篇"},{"categories":["数据库"],"content":" 1 通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#通用语法及分类"},{"categories":["数据库"],"content":" 1.1 DDL（数据定义语言）数据定义语言 1.1.1 数据库操作查询所有数据库： SHOW DATABASES; 查询当前数据库： SELECT DATABASE(); 创建数据库： CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 删除数据库： DROP DATABASE [ IF EXISTS ] 数据库名; 使用数据库： USE 数据库名; 1.1.1.1 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 1.1.2 表操作查询当前数据库所有表： SHOW TABLES; 查询表结构： DESC 表名; 查询指定表的建表语句： SHOW CREATE TABLE 表名; 创建表： mysql CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 例：将emp表的nickname字段修改为username，类型为varchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段： ALTER TABLE 表名 DROP 字段名; 修改表名： ALTER TABLE 表名 RENAME TO 新表名 删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#ddl数据定义语言"},{"categories":["数据库"],"content":" 1.1 DDL（数据定义语言）数据定义语言 1.1.1 数据库操作查询所有数据库： SHOW DATABASES; 查询当前数据库： SELECT DATABASE(); 创建数据库： CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 删除数据库： DROP DATABASE [ IF EXISTS ] 数据库名; 使用数据库： USE 数据库名; 1.1.1.1 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 1.1.2 表操作查询当前数据库所有表： SHOW TABLES; 查询表结构： DESC 表名; 查询指定表的建表语句： SHOW CREATE TABLE 表名; 创建表： mysql CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 例：将emp表的nickname字段修改为username，类型为varchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段： ALTER TABLE 表名 DROP 字段名; 修改表名： ALTER TABLE 表名 RENAME TO 新表名 删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#数据库操作"},{"categories":["数据库"],"content":" 1.1 DDL（数据定义语言）数据定义语言 1.1.1 数据库操作查询所有数据库： SHOW DATABASES; 查询当前数据库： SELECT DATABASE(); 创建数据库： CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 删除数据库： DROP DATABASE [ IF EXISTS ] 数据库名; 使用数据库： USE 数据库名; 1.1.1.1 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 1.1.2 表操作查询当前数据库所有表： SHOW TABLES; 查询表结构： DESC 表名; 查询指定表的建表语句： SHOW CREATE TABLE 表名; 创建表： mysql CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 例：将emp表的nickname字段修改为username，类型为varchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段： ALTER TABLE 表名 DROP 字段名; 修改表名： ALTER TABLE 表名 RENAME TO 新表名 删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项"},{"categories":["数据库"],"content":" 1.1 DDL（数据定义语言）数据定义语言 1.1.1 数据库操作查询所有数据库： SHOW DATABASES; 查询当前数据库： SELECT DATABASE(); 创建数据库： CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 删除数据库： DROP DATABASE [ IF EXISTS ] 数据库名; 使用数据库： USE 数据库名; 1.1.1.1 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 1.1.2 表操作查询当前数据库所有表： SHOW TABLES; 查询表结构： DESC 表名; 查询指定表的建表语句： SHOW CREATE TABLE 表名; 创建表： mysql CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 例：将emp表的nickname字段修改为username，类型为varchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段： ALTER TABLE 表名 DROP 字段名; 修改表名： ALTER TABLE 表名 RENAME TO 新表名 删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#表操作"},{"categories":["数据库"],"content":" 1.2 DML（数据操作语言） 1.2.1 添加数据指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 1.2.1.1 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 1.2.2 更新和删除数据修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 例： UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据： DELETE FROM 表名 [ WHERE 条件 ]; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#dml数据操作语言"},{"categories":["数据库"],"content":" 1.2 DML（数据操作语言） 1.2.1 添加数据指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 1.2.1.1 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 1.2.2 更新和删除数据修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 例： UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据： DELETE FROM 表名 [ WHERE 条件 ]; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#添加数据"},{"categories":["数据库"],"content":" 1.2 DML（数据操作语言） 1.2.1 添加数据指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 1.2.1.1 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 1.2.2 更新和删除数据修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 例： UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据： DELETE FROM 表名 [ WHERE 条件 ]; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-1"},{"categories":["数据库"],"content":" 1.2 DML（数据操作语言） 1.2.1 添加数据指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 1.2.1.1 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 1.2.2 更新和删除数据修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 例： UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据： DELETE FROM 表名 [ WHERE 条件 ]; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#更新和删除数据"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#dql数据查询语言"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基础查询"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#条件查询"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#聚合查询聚合函数"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#分组查询"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-2"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#排序查询"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-3"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#分页查询"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-4"},{"categories":["数据库"],"content":" 1.3 DQL（数据查询语言）语法： mysql SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 1.3.1 基础查询查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名; 设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录： SELECT DISTINCT 字段列表 FROM 表名; 转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符 1.3.2 条件查询语法： SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 \u003e 大于 \u003e= 大于等于 \u003c 小于 \u003c= 小于等于 = 等于 \u003c\u003e 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026\u0026 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： sql -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u003c 30; -- 小于等于 select * from employee where age \u003c= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u003e= 20 and age \u003c= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u003c 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 身份证最后为X select * from employee where idcard like '%X'; 1.3.3 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \"广东省\"; 1.3.4 分组查询语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u003c 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u003c 45 group by workaddress having address_count \u003e= 3; 1.3.4.1 注意事项 执行顺序：where \u003e 聚合函数 \u003e having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 1.3.5 排序查询语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： mysql -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 1.3.5.1 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 1.3.6 分页查询语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： mysql -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 1.3.6.1 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 1.3.7 DQL执行顺序FROM -\u003e WHERE -\u003e GROUP BY -\u003e SELECT -\u003e ORDER BY -\u003e LIMIT ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#dql执行顺序"},{"categories":["数据库"],"content":" 1.4 DCL 1.4.1 管理用户查询用户： mysql USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 例子： mysql -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 1.4.1.1 注意事项 主机名可以使用 % 通配 1.4.2 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看 权限一览表 查询权限： SHOW GRANTS FOR '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 1.4.2.1 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#dcl"},{"categories":["数据库"],"content":" 1.4 DCL 1.4.1 管理用户查询用户： mysql USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 例子： mysql -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 1.4.1.1 注意事项 主机名可以使用 % 通配 1.4.2 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看 权限一览表 查询权限： SHOW GRANTS FOR '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 1.4.2.1 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#管理用户"},{"categories":["数据库"],"content":" 1.4 DCL 1.4.1 管理用户查询用户： mysql USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 例子： mysql -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 1.4.1.1 注意事项 主机名可以使用 % 通配 1.4.2 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看 权限一览表 查询权限： SHOW GRANTS FOR '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 1.4.2.1 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-5"},{"categories":["数据库"],"content":" 1.4 DCL 1.4.1 管理用户查询用户： mysql USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 例子： mysql -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 1.4.1.1 注意事项 主机名可以使用 % 通配 1.4.2 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看 权限一览表 查询权限： SHOW GRANTS FOR '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 1.4.2.1 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#权限控制"},{"categories":["数据库"],"content":" 1.4 DCL 1.4.1 管理用户查询用户： mysql USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户： DROP USER '用户名'@'主机名'; 例子： mysql -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 1.4.1.1 注意事项 主机名可以使用 % 通配 1.4.2 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看 权限一览表 查询权限： SHOW GRANTS FOR '用户名'@'主机名'; 授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 1.4.2.1 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-6"},{"categories":["数据库"],"content":" 2 函数 字符串函数 数值函数 日期函数 流程函数 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#函数"},{"categories":["数据库"],"content":" 2.1 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 REPLACE(column, source, replace) 替换字符串 使用示例： mysql -- 拼接 SELECT CONCAT('Hello', 'World'); -- 小写 SELECT LOWER('Hello'); -- 大写 SELECT UPPER('Hello'); -- 左填充 SELECT LPAD('01', 5, '-'); -- 右填充 SELECT RPAD('01', 5, '-'); -- 去除空格 SELECT TRIM(' Hello World '); -- 切片（起始索引为1） SELECT SUBSTRING('Hello World', 1, 5); ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#字符串函数"},{"categories":["数据库"],"content":" 2.2 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#数值函数"},{"categories":["数据库"],"content":" 2.3 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： mysql -- DATE_ADD SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日期函数"},{"categories":["数据库"],"content":" 2.4 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： mysql select name, (case when age \u003e 30 then '中年' else '青年' end) from employee; select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址' from employee; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#流程函数"},{"categories":["数据库"],"content":" 3 约束(constraint)分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#约束constraint"},{"categories":["数据库"],"content":" 3.1 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： mysql create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age \u003e 0 and age \u003c 120), status char(1) default '1', gender char(1) ); ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#常用约束"},{"categories":["数据库"],"content":" 3.2 外键约束添加约束ADD CONSTRAINT 添加外键： mysql CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); -- 例子 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键： ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 3.2.1 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为： ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#外键约束"},{"categories":["数据库"],"content":" 3.2 外键约束添加约束ADD CONSTRAINT 添加外键： mysql CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); -- 例子 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键： ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 3.2.1 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为： ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#删除更新行为"},{"categories":["数据库"],"content":" 4 多表查询","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#多表查询"},{"categories":["数据库"],"content":" 4.1 多表关系 一对多（多对一） 多对多 一对一 4.1.1 一对多案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键 4.1.2 多对多案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 4.1.3 一对一案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#多表关系"},{"categories":["数据库"],"content":" 4.1 多表关系 一对多（多对一） 多对多 一对一 4.1.1 一对多案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键 4.1.2 多对多案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 4.1.3 一对一案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#一对多"},{"categories":["数据库"],"content":" 4.1 多表关系 一对多（多对一） 多对多 一对一 4.1.1 一对多案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键 4.1.2 多对多案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 4.1.3 一对一案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#多对多"},{"categories":["数据库"],"content":" 4.1 多表关系 一对多（多对一） 多对多 一对一 4.1.1 一对多案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键 4.1.2 多对多案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 4.1.3 一对一案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#一对一"},{"categories":["数据库"],"content":" 4.2 查询合并查询（笛卡尔积，会展示所有组合结果）： select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积： select * from employee, dept where employee.dept = dept.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#查询"},{"categories":["数据库"],"content":" 4.3 内连接查询内连接查询的是两张表交集的部分 隐式内连接： SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接： SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： mysql -- 查询员工姓名，及关联的部门的名称 -- 隐式 select e.name, d.name from employee as e, dept as d where e.dept = d.id; -- 显式 select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#内连接查询"},{"categories":["数据库"],"content":" 4.4 外连接查询左外连接： 查询左表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...; 相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接： 查询右表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： mysql -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#外连接查询"},{"categories":["数据库"],"content":" 4.5 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法： SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： mysql -- 查询员工及其所属领导的名字 select a.name, b.name from employee a, employee b where a.manager = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.manager = b.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#自连接查询"},{"categories":["数据库"],"content":" 4.6 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： mysql SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 4.6.1 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:6","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#联合查询-union-union-all"},{"categories":["数据库"],"content":" 4.6 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： mysql SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 4.6.1 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:6","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-7"},{"categories":["数据库"],"content":" 4.7 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 4.7.1 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u003c \u003e \u003e \u003e= \u003c \u003c= 例子： mysql -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u003e (select entrydate from employee where name = 'xxx'); 4.7.2 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： mysql -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u003e all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u003e any (select salary from employee where dept = (select id from dept where name = '研发部')); 4.7.3 行子查询返回的结果是一行（可以是多列）。 常用操作符：=, \u003c, \u003e, IN, NOT IN 例子： mysql -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 4.7.4 表子查询返回的结果是多行多列 常用操作符：IN 例子： mysql -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u003e '2006-01-01') as e left join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#子查询"},{"categories":["数据库"],"content":" 4.7 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 4.7.1 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u003c \u003e \u003e \u003e= \u003c \u003c= 例子： mysql -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u003e (select entrydate from employee where name = 'xxx'); 4.7.2 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： mysql -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u003e all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u003e any (select salary from employee where dept = (select id from dept where name = '研发部')); 4.7.3 行子查询返回的结果是一行（可以是多列）。 常用操作符：=, \u003c, \u003e, IN, NOT IN 例子： mysql -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 4.7.4 表子查询返回的结果是多行多列 常用操作符：IN 例子： mysql -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u003e '2006-01-01') as e left join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#标量子查询"},{"categories":["数据库"],"content":" 4.7 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 4.7.1 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u003c \u003e \u003e \u003e= \u003c \u003c= 例子： mysql -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u003e (select entrydate from employee where name = 'xxx'); 4.7.2 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： mysql -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u003e all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u003e any (select salary from employee where dept = (select id from dept where name = '研发部')); 4.7.3 行子查询返回的结果是一行（可以是多列）。 常用操作符：=, \u003c, \u003e, IN, NOT IN 例子： mysql -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 4.7.4 表子查询返回的结果是多行多列 常用操作符：IN 例子： mysql -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u003e '2006-01-01') as e left join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#列子查询"},{"categories":["数据库"],"content":" 4.7 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 4.7.1 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u003c \u003e \u003e \u003e= \u003c \u003c= 例子： mysql -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u003e (select entrydate from employee where name = 'xxx'); 4.7.2 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： mysql -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u003e all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u003e any (select salary from employee where dept = (select id from dept where name = '研发部')); 4.7.3 行子查询返回的结果是一行（可以是多列）。 常用操作符：=, \u003c, \u003e, IN, NOT IN 例子： mysql -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 4.7.4 表子查询返回的结果是多行多列 常用操作符：IN 例子： mysql -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u003e '2006-01-01') as e left join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#行子查询"},{"categories":["数据库"],"content":" 4.7 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 4.7.1 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u003c \u003e \u003e \u003e= \u003c \u003c= 例子： mysql -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u003e (select entrydate from employee where name = 'xxx'); 4.7.2 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： mysql -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u003e all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u003e any (select salary from employee where dept = (select id from dept where name = '研发部')); 4.7.3 行子查询返回的结果是一行（可以是多列）。 常用操作符：=, \u003c, \u003e, IN, NOT IN 例子： mysql -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 4.7.4 表子查询返回的结果是多行多列 常用操作符：IN 例子： mysql -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u003e '2006-01-01') as e left join dept as d on e.dept = d.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#表子查询"},{"categories":["数据库"],"content":" 5 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： mysql -- 1. 查询张三账户余额 select * from account where name = '张三'; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = '张三'; -- 此语句出错后张三钱减少但是李四钱没有增加 模拟sql语句错误 -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = '李四'; -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置手动提交后上面代码改为： select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 操作方式二： 开启事务： START TRANSACTION 或 BEGIN TRANSACTION; 提交事务： COMMIT; 回滚事务： ROLLBACK; 操作实例： mysql start transaction; select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#事务"},{"categories":["数据库"],"content":" 5.1 四大特性ACID https://www.cnblogs.com/cciejh/p/acid.html 原子性（Atomicity）：即不可分割性，事务中的操作要么全不做，要么全做 一致性（Consistency）：一个事务在执行前后，数据库都必须处于正确的状态，满足完整性约束 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability）：事务处理完成后，对数据的修改就是永久的，即便系统故障也不会丢失 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#四大特性acid"},{"categories":["数据库"],"content":" 5.2 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别： SELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别： SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }; SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#并发事务"},{"categories":["数据库"],"content":" 6 数据库隔离级别数据库隔离级别是用于控制多个事务并发访问数据库时的行为，它平衡了数据一致性和并发性能。不同的隔离级别对事务的并发操作有不同的限制，常见的隔离级别有以下四种，从低到高依次为： ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#数据库隔离级别"},{"categories":["数据库"],"content":" 6.1 读未提交（Read Uncommitted） 描述：这是最低的隔离级别，一个事务可以读取另一个未提交事务的数据。这种隔离级别允许脏读，即一个事务读取到了另一个事务未提交的数据，如果另一个事务回滚，那么读取到的数据就是无效的。 优点：并发性能最高，因为事务之间的相互阻塞最少。 缺点：数据的一致性最差，可能会出现脏读、不可重复读和幻读问题。 使用场景：对数据一致性要求不高，追求高并发性能的场景，例如某些统计分析系统。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#读未提交read-uncommitted"},{"categories":["数据库"],"content":" 6.2 读已提交（Read Committed） 描述：一个事务只能读取另一个已经提交事务的数据。避免了脏读，但可能会出现不可重复读的问题，即一个事务在两次读取同一数据时，由于另一个事务对该数据进行了修改并提交，导致两次读取结果不一致。 优点：避免了脏读，数据一致性有所提高。 缺点：仍然存在不可重复读和幻读问题。 使用场景：大多数数据库系统的默认隔离级别，适用于对数据一致性有一定要求，但对并发性能也有一定要求的场景，例如普通的业务系统。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#读已提交read-committed"},{"categories":["数据库"],"content":" 6.3 可重复读（Repeatable Read） 描述：在同一个事务中，多次读取同一数据的结果是一致的。为了实现这一点，数据库会对读取的数据加锁，防止其他事务对其进行修改。但可能会出现幻读问题，即一个事务在两次查询同一范围的数据时，由于另一个事务插入了新的数据（新的数据没有锁），导致两次查询结果不一致。 优点：避免了脏读和不可重复读，数据一致性进一步提高。 缺点：仍然存在幻读问题，并发性能相对较低。 使用场景：适用于对数据一致性要求较高，对并发性能要求相对较低的场景，例如金融系统。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#可重复读repeatable-read"},{"categories":["数据库"],"content":" 6.4 串行化（Serializable） 描述：这是最高的隔离级别，所有事务依次串行执行，事务之间完全不会相互干扰。避免了脏读、不可重复读和幻读问题。 优点：数据一致性最高，不会出现任何并发问题。 缺点：并发性能最低，因为事务需要依次执行，可能会导致大量的等待时间。 使用场景：适用于对数据一致性要求极高，对并发性能要求极低的场景，例如某些关键的财务系统。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#串行化serializable"},{"categories":["数据库"],"content":" 6.5 不同数据库的默认隔离级别 MySQL：默认隔离级别是可重复读（Repeatable Read）。 Oracle：默认隔离级别是读已提交（Read Committed）。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#不同数据库的默认隔离级别"},{"categories":["数据库"],"content":" 6.6 示例代码（以 MySQL 为例）你可以通过以下 SQL 语句来设置和查看当前会话的隔离级别： sql -- 设置隔离级别为读未提交 SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- 设置隔离级别为读已提交 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 设置隔离级别为可重复读 SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 设置隔离级别为串行化 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; -- 查看当前会话的隔离级别 SELECT @@tx_isolation; 在实际应用中，需要根据具体的业务需求来选择合适的隔离级别，在数据一致性和并发性能之间找到平衡。 #NOTE TODO 1.RU 不带锁 2.RC有写锁无读锁 3.RR读写均有锁（只锁已存在的数据） 4.串行一条条来，锁操作 幻读，难以处理是因为，没有办法去 行锁一条不存在的数据 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:6","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#示例代码以-mysql-为例"},{"categories":["数据库"],"content":" 进阶篇","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#进阶篇"},{"categories":["数据库"],"content":" 1 存储引擎MySQL体系结构： 结构图 层级描述 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。 默认存储引擎是InnoDB。 相关操作： mysql -- 查询建表语句 show create table account; -- 建表时指定存储引擎 CREATE TABLE 表名( ... ) ENGINE=INNODB; -- 查看当前数据库支持的存储引擎 show engines; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#存储引擎"},{"categories":["数据库"],"content":" 1.1 InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量： show variables like 'innodb_file_per_table'; 从idb文件提取表结构数据： （在cmd运行） ibd2sdi xxx.ibd InnoDB 逻辑存储结构： InnoDB逻辑存储结构 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#innodb"},{"categories":["数据库"],"content":" 1.2 MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#myisam"},{"categories":["数据库"],"content":" 1.3 MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#memory"},{"categories":["数据库"],"content":" 1.4 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#存储引擎特点"},{"categories":["数据库"],"content":" 1.5 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#存储引擎的选择"},{"categories":["数据库"],"content":" 2 性能分析","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#性能分析"},{"categories":["数据库"],"content":" 2.1 查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次： SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______'; 例：show global status like 'Com_______' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#查看执行频次"},{"categories":["数据库"],"content":" 2.2 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。 MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2 更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log 查看慢查询日志开关状态： show variables like 'slow_query_log'; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#慢查询日志"},{"categories":["数据库"],"content":" 2.3 profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作： SELECT @@have_profiling; profiling 默认关闭，可以通过set语句在session/global级别开启 profiling： SET profiling = 1; 查看所有语句的耗时： show profiles; 查看指定query_id的SQL语句各个阶段的耗时： show profile for query query_id; 查看指定query_id的SQL语句CPU的使用情况 show profile cpu for query query_id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#profile"},{"categories":["数据库"],"content":" 2.4 explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#explain"},{"categories":["数据库"],"content":" 3 索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#索引"},{"categories":["数据库"],"content":" 3.1 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 3.1.1 B-Tree二叉树 二叉树的缺点可以用红黑树来解决： 红黑树 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree结构 B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3.1.2 B+Tree结构图： B+Tree结构图 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 （叶子没有的话，不需要回表） 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。（环形双向链表） MySQL B+Tree 结构图 3.1.3 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 Hash索引原理图 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u003e、\u003c、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 3.1.4 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#索引结构"},{"categories":["数据库"],"content":" 3.1 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 3.1.1 B-Tree二叉树 二叉树的缺点可以用红黑树来解决： 红黑树 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree结构 B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3.1.2 B+Tree结构图： B+Tree结构图 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 （叶子没有的话，不需要回表） 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。（环形双向链表） MySQL B+Tree 结构图 3.1.3 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 Hash索引原理图 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u003e、\u003c、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 3.1.4 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#b-tree"},{"categories":["数据库"],"content":" 3.1 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 3.1.1 B-Tree二叉树 二叉树的缺点可以用红黑树来解决： 红黑树 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree结构 B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3.1.2 B+Tree结构图： B+Tree结构图 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 （叶子没有的话，不需要回表） 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。（环形双向链表） MySQL B+Tree 结构图 3.1.3 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 Hash索引原理图 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u003e、\u003c、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 3.1.4 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#btree"},{"categories":["数据库"],"content":" 3.1 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 3.1.1 B-Tree二叉树 二叉树的缺点可以用红黑树来解决： 红黑树 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree结构 B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3.1.2 B+Tree结构图： B+Tree结构图 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 （叶子没有的话，不需要回表） 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。（环形双向链表） MySQL B+Tree 结构图 3.1.3 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 Hash索引原理图 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u003e、\u003c、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 3.1.4 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#hash"},{"categories":["数据库"],"content":" 3.1 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 3.1.1 B-Tree二叉树 二叉树的缺点可以用红黑树来解决： 红黑树 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree结构 B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html 3.1.2 B+Tree结构图： B+Tree结构图 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 （叶子没有的话，不需要回表） 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。（环形双向链表） MySQL B+Tree 结构图 3.1.3 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 Hash索引原理图 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u003e、\u003c、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 3.1.4 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#面试题"},{"categories":["数据库"],"content":" 3.2 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 二级索引 需要从主键再查询数据 – 回表查询 演示图： 大致原理 演示图 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 3.2.1 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ mysql select * from user where id = 10; select * from user where name = 'Arm'; -- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ – TODO 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8. 可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736； 如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#索引分类"},{"categories":["数据库"],"content":" 3.2 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 二级索引 需要从主键再查询数据 – 回表查询 演示图： 大致原理 演示图 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 3.2.1 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ mysql select * from user where id = 10; select * from user where name = 'Arm'; -- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ – TODO 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8. 可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736； 如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#思考题"},{"categories":["数据库"],"content":" 3.3 语法创建索引： CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...); 如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引： SHOW INDEX FROM table_name; 删除索引： DROP INDEX index_name ON table_name; 案例： mysql -- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引 create index idx_user_name on tb_user(name); -- phone手机号字段的值非空，且唯一，为该字段创建唯一索引 create unique index idx_user_phone on tb_user (phone); -- 为profession, age, status创建联合索引 create index idx_user_pro_age_stat on tb_user(profession, age, status); -- 为email建立合适的索引来提升查询效率 create index idx_user_email on tb_user(email); -- 删除索引 drop index idx_user_email on tb_user; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#语法"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#使用规则"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#最左前缀法则"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#索引失效情况"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#sql-提示"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#覆盖索引回表查询"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#前缀索引"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#单列索引联合索引"},{"categories":["数据库"],"content":" 3.4 使用规则 3.4.1 最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（\u003c, \u003e），范围查询右侧的列索引失效。可以用\u003e=或者\u003c=来规避索引失效问题。 TODO — 都有什么索引失效的场景 3.4.2 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 3.4.3 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\"; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\"; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\"; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 3.4.4 覆盖索引\u0026回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 3.4.5 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式： TODO 选择性是什么？ mysql select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 3.4.6 单列索引\u0026联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段 3.4.6.1 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#注意事项-8"},{"categories":["数据库"],"content":" 3.5 设计原则 3.5.1 什么字段建立索引 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#设计原则"},{"categories":["数据库"],"content":" 3.5 设计原则 3.5.1 什么字段建立索引 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#什么字段建立索引"},{"categories":["数据库"],"content":" 4 SQL 优化","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#sql-优化"},{"categories":["数据库"],"content":" 4.1 插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入： 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 mysql # 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入） mysql --local-infile -u root -p # 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile = 1; select @@local_infile; # 执行load指令将准备好的数据，加载到表结构中 load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n'; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#插入数据"},{"categories":["数据库"],"content":" 4.2 主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） 页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。 页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90 主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#主键优化"},{"categories":["数据库"],"content":" 4.3 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#order-by优化"},{"categories":["数据库"],"content":" 4.4 group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#group-by优化"},{"categories":["数据库"],"content":" 4.5 limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。 优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： mysql -- 此语句耗时很长 select * from tb_sku limit 9000000, 10; -- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询 select id from tb_sku order by id limit 9000000, 10; -- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit -- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10); -- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度 select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#limit优化"},{"categories":["数据库"],"content":" 4.6 count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）； InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。 优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis count的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) \u003c count(主键) \u003c count(1) \u003c count(*)，所以尽量使用 count(*) ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:6","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#count优化"},{"categories":["数据库"],"content":" 4.7 update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句： update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行； update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#update优化避免行锁升级为表锁"},{"categories":["数据库"],"content":" 5 视图/存储过程/触发器 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#视图存储过程触发器"},{"categories":["数据库"],"content":" 5.1 视图视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 5.1.1 语法创建视图： CREATE [OR REPLACE] VIEW 视图名称(列名列表)】AS SELECT语句[WITH[CASCADED|LOCAL] CHECK OPTION] 查询视图： 查看创建视图语句：SHOW CRETE VIEW 视图名称; 查看视图数据：查看视图数据:SELECT*FROM 视图名称…; 修改视图： 方式一： CREATE [OR REPLACE]VIEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADEDLLOCAL] CHECK OPTION 方式二： ALTER VEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADED|LOCAL]CHECK OPTION] 删除视图： DROP VIEW [IF EXISTS]视图名称[,视图名称] sql -- 创建视图 create or replace view stu_v_1 as select id, name from student where id \u003c= 10; -- 查询视图 show create view stu_v_1; select * from stu_v_1; -- 修改视图 create or replace view stu_v_1 as select id, name, no from student where id \u003c= 10; alter view stu_v_1 as select id, name from student where id \u003c= 10; -- 删除视图 drop view if exists stu_v_1;/* */ 5.1.2 检查选项视图的检查选项： 当使用WITH CHECK OPTION子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。MVSOL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。 为了确定检查的范围，mysql 提供了两个选项:CASCADED 和 LOCAL，默认值为CASCADED。 cascaded：在对创建时含有该字段的视图，插入数据时，该视图依赖的视图都会加上检查，需要所有条件都满足才能够插入成功。 local：在对创建时含有该字段的视图，插入数据时，对于该视图依赖的视图中含有检查语句的条件进行检查判断。 5.1.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。 如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等 DISTINCT GROUP BY HAVINGA UNION 或者 UNION ALL 作用： 简单 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.1.4 案例 sql -- 1.为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。 create view tb user view as select id,name,profession, age,gender,status,createtime from tb_user; select *from tb user view; -- 2.查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。 create view tb_stu_course_view select s.name student_name, s.no student_no, c.name course_name from student s, stuent_course sc, course c where s.id = sc.studentid and sc.courseid = c.id; -- 以后每次只需要进行查询视图即可 select * from tb_stu_course_view; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#视图"},{"categories":["数据库"],"content":" 5.1 视图视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 5.1.1 语法创建视图： CREATE [OR REPLACE] VIEW 视图名称(列名列表)】AS SELECT语句[WITH[CASCADED|LOCAL] CHECK OPTION] 查询视图： 查看创建视图语句：SHOW CRETE VIEW 视图名称; 查看视图数据：查看视图数据:SELECT*FROM 视图名称…; 修改视图： 方式一： CREATE [OR REPLACE]VIEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADEDLLOCAL] CHECK OPTION 方式二： ALTER VEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADED|LOCAL]CHECK OPTION] 删除视图： DROP VIEW [IF EXISTS]视图名称[,视图名称] sql -- 创建视图 create or replace view stu_v_1 as select id, name from student where id \u003c= 10; -- 查询视图 show create view stu_v_1; select * from stu_v_1; -- 修改视图 create or replace view stu_v_1 as select id, name, no from student where id \u003c= 10; alter view stu_v_1 as select id, name from student where id \u003c= 10; -- 删除视图 drop view if exists stu_v_1;/* */ 5.1.2 检查选项视图的检查选项： 当使用WITH CHECK OPTION子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。MVSOL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。 为了确定检查的范围，mysql 提供了两个选项:CASCADED 和 LOCAL，默认值为CASCADED。 cascaded：在对创建时含有该字段的视图，插入数据时，该视图依赖的视图都会加上检查，需要所有条件都满足才能够插入成功。 local：在对创建时含有该字段的视图，插入数据时，对于该视图依赖的视图中含有检查语句的条件进行检查判断。 5.1.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。 如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等 DISTINCT GROUP BY HAVINGA UNION 或者 UNION ALL 作用： 简单 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.1.4 案例 sql -- 1.为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。 create view tb user view as select id,name,profession, age,gender,status,createtime from tb_user; select *from tb user view; -- 2.查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。 create view tb_stu_course_view select s.name student_name, s.no student_no, c.name course_name from student s, stuent_course sc, course c where s.id = sc.studentid and sc.courseid = c.id; -- 以后每次只需要进行查询视图即可 select * from tb_stu_course_view; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#语法-1"},{"categories":["数据库"],"content":" 5.1 视图视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 5.1.1 语法创建视图： CREATE [OR REPLACE] VIEW 视图名称(列名列表)】AS SELECT语句[WITH[CASCADED|LOCAL] CHECK OPTION] 查询视图： 查看创建视图语句：SHOW CRETE VIEW 视图名称; 查看视图数据：查看视图数据:SELECT*FROM 视图名称…; 修改视图： 方式一： CREATE [OR REPLACE]VIEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADEDLLOCAL] CHECK OPTION 方式二： ALTER VEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADED|LOCAL]CHECK OPTION] 删除视图： DROP VIEW [IF EXISTS]视图名称[,视图名称] sql -- 创建视图 create or replace view stu_v_1 as select id, name from student where id \u003c= 10; -- 查询视图 show create view stu_v_1; select * from stu_v_1; -- 修改视图 create or replace view stu_v_1 as select id, name, no from student where id \u003c= 10; alter view stu_v_1 as select id, name from student where id \u003c= 10; -- 删除视图 drop view if exists stu_v_1;/* */ 5.1.2 检查选项视图的检查选项： 当使用WITH CHECK OPTION子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。MVSOL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。 为了确定检查的范围，mysql 提供了两个选项:CASCADED 和 LOCAL，默认值为CASCADED。 cascaded：在对创建时含有该字段的视图，插入数据时，该视图依赖的视图都会加上检查，需要所有条件都满足才能够插入成功。 local：在对创建时含有该字段的视图，插入数据时，对于该视图依赖的视图中含有检查语句的条件进行检查判断。 5.1.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。 如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等 DISTINCT GROUP BY HAVINGA UNION 或者 UNION ALL 作用： 简单 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.1.4 案例 sql -- 1.为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。 create view tb user view as select id,name,profession, age,gender,status,createtime from tb_user; select *from tb user view; -- 2.查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。 create view tb_stu_course_view select s.name student_name, s.no student_no, c.name course_name from student s, stuent_course sc, course c where s.id = sc.studentid and sc.courseid = c.id; -- 以后每次只需要进行查询视图即可 select * from tb_stu_course_view; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#检查选项"},{"categories":["数据库"],"content":" 5.1 视图视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 5.1.1 语法创建视图： CREATE [OR REPLACE] VIEW 视图名称(列名列表)】AS SELECT语句[WITH[CASCADED|LOCAL] CHECK OPTION] 查询视图： 查看创建视图语句：SHOW CRETE VIEW 视图名称; 查看视图数据：查看视图数据:SELECT*FROM 视图名称…; 修改视图： 方式一： CREATE [OR REPLACE]VIEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADEDLLOCAL] CHECK OPTION 方式二： ALTER VEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADED|LOCAL]CHECK OPTION] 删除视图： DROP VIEW [IF EXISTS]视图名称[,视图名称] sql -- 创建视图 create or replace view stu_v_1 as select id, name from student where id \u003c= 10; -- 查询视图 show create view stu_v_1; select * from stu_v_1; -- 修改视图 create or replace view stu_v_1 as select id, name, no from student where id \u003c= 10; alter view stu_v_1 as select id, name from student where id \u003c= 10; -- 删除视图 drop view if exists stu_v_1;/* */ 5.1.2 检查选项视图的检查选项： 当使用WITH CHECK OPTION子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。MVSOL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。 为了确定检查的范围，mysql 提供了两个选项:CASCADED 和 LOCAL，默认值为CASCADED。 cascaded：在对创建时含有该字段的视图，插入数据时，该视图依赖的视图都会加上检查，需要所有条件都满足才能够插入成功。 local：在对创建时含有该字段的视图，插入数据时，对于该视图依赖的视图中含有检查语句的条件进行检查判断。 5.1.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。 如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等 DISTINCT GROUP BY HAVINGA UNION 或者 UNION ALL 作用： 简单 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.1.4 案例 sql -- 1.为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。 create view tb user view as select id,name,profession, age,gender,status,createtime from tb_user; select *from tb user view; -- 2.查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。 create view tb_stu_course_view select s.name student_name, s.no student_no, c.name course_name from student s, stuent_course sc, course c where s.id = sc.studentid and sc.courseid = c.id; -- 以后每次只需要进行查询视图即可 select * from tb_stu_course_view; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#更新及作用"},{"categories":["数据库"],"content":" 5.1 视图视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 5.1.1 语法创建视图： CREATE [OR REPLACE] VIEW 视图名称(列名列表)】AS SELECT语句[WITH[CASCADED|LOCAL] CHECK OPTION] 查询视图： 查看创建视图语句：SHOW CRETE VIEW 视图名称; 查看视图数据：查看视图数据:SELECT*FROM 视图名称…; 修改视图： 方式一： CREATE [OR REPLACE]VIEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADEDLLOCAL] CHECK OPTION 方式二： ALTER VEW 视图名称(列名列表)AS SELECT语句[WITH[CASCADED|LOCAL]CHECK OPTION] 删除视图： DROP VIEW [IF EXISTS]视图名称[,视图名称] sql -- 创建视图 create or replace view stu_v_1 as select id, name from student where id \u003c= 10; -- 查询视图 show create view stu_v_1; select * from stu_v_1; -- 修改视图 create or replace view stu_v_1 as select id, name, no from student where id \u003c= 10; alter view stu_v_1 as select id, name from student where id \u003c= 10; -- 删除视图 drop view if exists stu_v_1;/* */ 5.1.2 检查选项视图的检查选项： 当使用WITH CHECK OPTION子句创建视图时，MySOL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。MVSOL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。 为了确定检查的范围，mysql 提供了两个选项:CASCADED 和 LOCAL，默认值为CASCADED。 cascaded：在对创建时含有该字段的视图，插入数据时，该视图依赖的视图都会加上检查，需要所有条件都满足才能够插入成功。 local：在对创建时含有该字段的视图，插入数据时，对于该视图依赖的视图中含有检查语句的条件进行检查判断。 5.1.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。 如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等 DISTINCT GROUP BY HAVINGA UNION 或者 UNION ALL 作用： 简单 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.1.4 案例 sql -- 1.为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。 create view tb user view as select id,name,profession, age,gender,status,createtime from tb_user; select *from tb user view; -- 2.查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。 create view tb_stu_course_view select s.name student_name, s.no student_no, c.name course_name from student s, stuent_course sc, course c where s.id = sc.studentid and sc.courseid = c.id; -- 以后每次只需要进行查询视图即可 select * from tb_stu_course_view; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#案例"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#存储过程"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基本语法"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#变量"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#系统变量"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#用户定义变量"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#局部变量"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#if-判断"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#参数in-out-inout"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#case"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#循环"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#while"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#repeat"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#loop"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#游标-cursor"},{"categories":["数据库"],"content":" 5.2 存储过程存储过程其实就类似 java，c 这种语言，这一部分可以通过文档快速学习，不懂的再回过头看视频。 存储过程是事先经过编译并存储在数据库中的一段 SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.2.1 基本语法TODO 这个作用在哪个阶段？？ 查看视图数据:SELECT*FROM 视图名称…; 查看： SELECT* FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='xx';--查询数据库的存储过程及状态信息 SHOW CREATE PROCEDURE 存储过程名称;--查询某个存储过程的定义 删除： DROP PROCEDURE [IF EXISTS]存储过程名称; 案例： sql -- 存储过程基本语法 -- 创建 create procedure p1() begin select count(*)from student; end; -- 调用 call p1(); -- 查看 select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast'; show create procedure p1; -- 删除 drop procedure if exists p1; 5.2.2 变量 5.2.2.1 系统变量系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)。 查看系统变量 SHOW [SESSION |GLOBAL] VARIABLES ; --查看所有系统变量 SHOW[SESSION|GLOBAL] VARIABLES LIKE'; --可以通过LKE模糊匹配方式查找变量 SELECT @@[SESSION|GLOBAL]系统变量名; -- 查看指定变量的值 sql -- 变量：系统变量 -- 查看系统变量 show session variables; show session variables like 'auto%'; show glabal variables like 'auto%'; select @@global.autocommit; -- 设置系统变量 set session autocommit = 1; insert intto course(id, name) values (6, 'ES'); set global auto commit = 0; 注意： 如果没有指定 session / global，默认 session，会话变量 myesql 服务器重启之后，所设置的全局参数会失效，要想不失效，需要更改/etc/my.cnf 中的配置。 5.2.2.2 用户定义变量用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。 赋值： SET @var name = expr [, @var_name = expr]...; SET @var name := expr [, @var_name := expr]...; SELECT @var name := expr , @var name := expr ...; SELECT 字段名 INTO @var_name FROM 表名; 使用： SELECT @var_name; 案例： sql -- 变量：用户变量 -- 赋值 set @myname = 'itcast'; set @myage := 10; select @mycolor := 'red'; select count(*) into @mycount from tb_user; -- 使用 select @myname, @myage, @mycolor, @mycount; select @abc; -- 输出为NULL 注意： 用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为 NULL。 5.2.2.3 局部变量局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN .. END块。 声明： DECLARE 变量名 变量类型 [DEFAULT..]; 变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。 赋值： SET 变量名=值; SET 变量名:=值; SELECT 字段名 INTO 变量名 FROM 表名 ...; 案例： sql -- 变量：局部变量 -- 声明 - declare -- 赋值 - create procedure p2() begin declare stu_count int default 0; select count(*) into stu_count from student; select stu_count; end; call p2(); 5.2.3 if 判断语法： sql IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; 案例： sql create procedure p3() begin declare score int default 58; declare result varchar(10); if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; 5.2.4 参数（in, out, inout) 类型 含义 备注 IN 该类参数作为输入，也就是需要调用时传入值 默认 OUT 该类参数作为输出，也就是该参数可以作为返回值 INOUT 既可以作为输入参数，也可以作为输出参数**** 用法： sql CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型 ]) BEGIN -- SQL语句 END : 案例： sql -- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out) -- score \u003e= 85分，等级为优秀。 -- score \u003e= 60分 且 score \u003c 85分，等级为及格 -- score \u003c 60分，等级为不及格。 create procedure p3(in score int, out result varchar(10)) begin if score \u003e= 85 then set result :='优秀'; elseif score \u003e= 60 then set result :='及格'; else set result :='不及格'; end if; select result; end; -- 将传入的200分制的分数，进行换算，换算成百分制，然后返回分数 --\u003e inout create procedure p5(inout score double) begin set score := score * 0.5; end; set @score = 198; call p5(score); select @score; 5.2.5 case语法一： sql CASE case value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2]... [ELSE statement_list ] END CASE; 语法二： sql CASE WHEN search_conditionl THEN statement_list1 WHEN search_condition2 THEN statement_list2]... [ELSE statement_list] END CASE; 案例： sql -- case -- 根据传入的月份，判定月份所属的季节(要求采用case结构) -- 1-3月份，为第一季度 -- 4-6月份，为第二季度 -- 7-9月份，为第三季度 -- 10-12月份，为第四季度 create procedure p6(in month int) begin declare result varchar(10); case when month \u003e= 1 and month \u003c= 3 then set result := '第一季度'; when month \u003e= 4 and month \u003c= 6 then set result := '第二季度'; when month \u003e= 7 and month \u003c= 9 then set result := ' 第三季度'; when month \u003e= 10 and month \u003c= 12 then set result := '第四季度'; else set result := '非法参数'; e","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#条件处理程序-handler"},{"categories":["数据库"],"content":" 5.3 存储函数：存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。 存储函数用的较少，能够使用存储函数的地方都可以用存储过程替换。 语法： sql CREATE FUNCTION 存储函数名称([ 参数列表 ]) RETURNS type [characteristic ...] BEGIN -- SQL语句 RETURN ...; END ; characteristic说明: · DETERMINISTIC:相同的输入参数总是产生相同的结果 · NO SQL:不包含 SQL语句。 · READS SOL DATA:包含读取数据的语句，但不包含写入数据的语句, 案例： sql create function fun1(n int) returns int deterministic begin declare total int default 0; while n \u003e 0 do set total := total + n; set n := n - 1; end while; return total; end; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#存储函数"},{"categories":["数据库"],"content":" 5.4 触发器触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD insert 型触发器 NEW 表示将要或者已经新增的数据 update 型触发器 OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据 delete 型触发器 OLD 表示将要或者已经删除的数据 语法： 创建： sql CREATE TRIGGER trigger name BEFORE/AFTER INSERT/UPDATE/DELETE ON tbl name FOR EACH ROW --行级触发器BEGIN trigger_stmt; END; 查看： sql SHOW TRIGGERS; 删除： sql DROP TRIGGER [schema_name.]trigger_name; --如果没有指定 schema name，默认为当前数据库 案例： sql -- 插入数据触发器 create trigger tb_user_insert_trigger after insert on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params)values (null, 'insert', now(), new.id, concat('插入的数据内容为：id=', new.id, ',name=', new.name, ', phone=', new.phone, ', email=', new.email, ', profession=', new.profession)); end; -- 查看 show triggers; -- 删除 drop trigger tb_user_insert_trigger; -- 插入数据tb_user insert into tb_user(id, name, phtone, email, profession, age, gender, status, createtime) values(25, '二皇子', '1880901212', 'erhuangzi@163.com', '软件工程', 23, '1', '1'1, now()); -- 修改数据触发器 create trigger tb_user_update_trigger after update on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params)values (null, 'update', now(), new.id, concat('更新之前的数据：id=', old.id, ',name=', old.name, ', phone=', old.phone, ', email=', old.email, ', profession=', old.profession, '更新之后的数据：id=', new.id, ',name=', new.name, ', phone=', new.phone, ', email=', new.email, ', profession=', new.profession)); end; update tb_user set age = 32 where id = 23; update tb_user set age = 32 where id \u003c= 5; -- 触发器为行级触发器，所以更改几行数据则出发几次，该语句出发5次 -- 删除数据触发器 create trigger tb_user_delete_trigger after delete on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params)values (null, 'insert', now(), old.id, concat('删除之前的数据：id=', new.id, ',name=', old.name, ', phone=', old.phone, ', email=', old.email, ', profession=', old.profession)); end; delete from tb_user where id = 26; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#触发器"},{"categories":["数据库"],"content":" 6 锁介绍： 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I/0)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 分类： MySQL中的锁，按照锁的粒度分，分为一下三类： 全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#锁"},{"categories":["数据库"],"content":" 6.1 全局锁介绍： 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。 基本操作： 使用全局锁：flush tables with read lock 释放全局锁：unlock tables 演示图： 特点： 数据库中加全局锁，是一个比较重的操作，存在以下问题: 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟。（该结构会在后续主从复制讲解） 解决方法： 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份。 mysqldump --single-transaction -uroot -p123456 itcast \u003e itcast.sql（只适用于支持「可重复读隔离级别的事务」的存储引擎） 原理补充：通过加上这个参数，确保了在备份开始时创建一个一致性的快照，通过启动一个新的事务来实现这一点。（该事务的隔离级别是Repeatable Read级别），从而实现在该事务读取下一直读取的是创建时的数据，而不影响其他事务的读写操作。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#全局锁"},{"categories":["数据库"],"content":" 6.2 表级锁每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为一下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 6.2.1 表锁对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 读锁不会阻塞其他客户端的读，但是会阻塞写（当前客户端不能写）。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 语法： sql //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tebles t_student read; //表级锁的独占锁，也是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放所有锁： unlock tables （会话退出，也会释放所有锁） 6.2.2 元数据锁TODO 元数据是？ MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表 上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL（定义与操作）冲突，保证读写的正确性。 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 对应SQL 锁类型 说明 lock tables xxx read /write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、 select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select …for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table … EXCLYSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 6.2.3 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向锁的目的是为了快速判断表里是否有记录被加锁。 加锁方式： 意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁） 由 select ... lock in share mode 添加 意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁） 由 insert、update、delete、select ... for update 添加 6.2.4 AUTO-INC锁（补充） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#表级锁"},{"categories":["数据库"],"content":" 6.2 表级锁每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为一下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 6.2.1 表锁对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 读锁不会阻塞其他客户端的读，但是会阻塞写（当前客户端不能写）。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 语法： sql //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tebles t_student read; //表级锁的独占锁，也是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放所有锁： unlock tables （会话退出，也会释放所有锁） 6.2.2 元数据锁TODO 元数据是？ MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表 上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL（定义与操作）冲突，保证读写的正确性。 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 对应SQL 锁类型 说明 lock tables xxx read /write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、 select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select …for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table … EXCLYSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 6.2.3 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向锁的目的是为了快速判断表里是否有记录被加锁。 加锁方式： 意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁） 由 select ... lock in share mode 添加 意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁） 由 insert、update、delete、select ... for update 添加 6.2.4 AUTO-INC锁（补充） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#表锁"},{"categories":["数据库"],"content":" 6.2 表级锁每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为一下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 6.2.1 表锁对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 读锁不会阻塞其他客户端的读，但是会阻塞写（当前客户端不能写）。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 语法： sql //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tebles t_student read; //表级锁的独占锁，也是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放所有锁： unlock tables （会话退出，也会释放所有锁） 6.2.2 元数据锁TODO 元数据是？ MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表 上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL（定义与操作）冲突，保证读写的正确性。 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 对应SQL 锁类型 说明 lock tables xxx read /write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、 select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select …for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table … EXCLYSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 6.2.3 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向锁的目的是为了快速判断表里是否有记录被加锁。 加锁方式： 意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁） 由 select ... lock in share mode 添加 意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁） 由 insert、update、delete、select ... for update 添加 6.2.4 AUTO-INC锁（补充） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#元数据锁"},{"categories":["数据库"],"content":" 6.2 表级锁每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为一下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 6.2.1 表锁对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 读锁不会阻塞其他客户端的读，但是会阻塞写（当前客户端不能写）。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 语法： sql //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tebles t_student read; //表级锁的独占锁，也是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放所有锁： unlock tables （会话退出，也会释放所有锁） 6.2.2 元数据锁TODO 元数据是？ MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表 上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL（定义与操作）冲突，保证读写的正确性。 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 对应SQL 锁类型 说明 lock tables xxx read /write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、 select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select …for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table … EXCLYSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 6.2.3 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向锁的目的是为了快速判断表里是否有记录被加锁。 加锁方式： 意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁） 由 select ... lock in share mode 添加 意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁） 由 insert、update、delete、select ... for update 添加 6.2.4 AUTO-INC锁（补充） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#意向锁"},{"categories":["数据库"],"content":" 6.2 表级锁每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为一下三类： 表锁 元数据锁（meta data lock，MDL） 意向锁 6.2.1 表锁对于表锁，分为两类： 表共享读锁（read lock） 表独占写锁（write lock） 读锁不会阻塞其他客户端的读，但是会阻塞写（当前客户端不能写）。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 语法： sql //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tebles t_student read; //表级锁的独占锁，也是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放所有锁： unlock tables （会话退出，也会释放所有锁） 6.2.2 元数据锁TODO 元数据是？ MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表 上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL（定义与操作）冲突，保证读写的正确性。 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； 对应SQL 锁类型 说明 lock tables xxx read /write SHARED_READ_ONLY/SHARED_NO_READ_WRITE select 、 select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert 、update、delete、select …for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table … EXCLYSIVE 与其他的MDL都互斥 查看元数据锁： select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks; 6.2.3 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向锁的目的是为了快速判断表里是否有记录被加锁。 加锁方式： 意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁） 由 select ... lock in share mode 添加 意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁） 由 insert、update、delete、select ... for update 添加 6.2.4 AUTO-INC锁（补充） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#auto-inc锁补充"},{"categories":["数据库"],"content":" 6.3 行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁(GapLock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 临键锁(Next-Key Lock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 6.3.1 Record Lock（行锁）Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分。 InnoDB实现了以下两种类型的行锁： 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 S(共享锁) X(排他锁) S(共享锁) 兼容 冲突 X(排他锁) 冲突 冲突 行锁类型： SQL 行锁类型 说明 insert，update，delete … 排他锁 自动加锁 select 不加任何锁 select … lock in share mode 共享锁 需要手动select之后加上lock in share mode select … for update 排他锁 需要手动在select之后for update 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么!nnoDB将对表中的所有记录加锁，此时 就会升级为表锁。 查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from peformance_schema.data_locks; 6.3.2 Gap Lock（间隙锁） 6.3.3 Next-Key Lock（临键锁） 默认情况下，InnODB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁 。 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#行级锁"},{"categories":["数据库"],"content":" 6.3 行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁(GapLock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 临键锁(Next-Key Lock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 6.3.1 Record Lock（行锁）Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分。 InnoDB实现了以下两种类型的行锁： 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 S(共享锁) X(排他锁) S(共享锁) 兼容 冲突 X(排他锁) 冲突 冲突 行锁类型： SQL 行锁类型 说明 insert，update，delete … 排他锁 自动加锁 select 不加任何锁 select … lock in share mode 共享锁 需要手动select之后加上lock in share mode select … for update 排他锁 需要手动在select之后for update 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么!nnoDB将对表中的所有记录加锁，此时 就会升级为表锁。 查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from peformance_schema.data_locks; 6.3.2 Gap Lock（间隙锁） 6.3.3 Next-Key Lock（临键锁） 默认情况下，InnODB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁 。 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#record-lock行锁"},{"categories":["数据库"],"content":" 6.3 行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁(GapLock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 临键锁(Next-Key Lock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 6.3.1 Record Lock（行锁）Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分。 InnoDB实现了以下两种类型的行锁： 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 S(共享锁) X(排他锁) S(共享锁) 兼容 冲突 X(排他锁) 冲突 冲突 行锁类型： SQL 行锁类型 说明 insert，update，delete … 排他锁 自动加锁 select 不加任何锁 select … lock in share mode 共享锁 需要手动select之后加上lock in share mode select … for update 排他锁 需要手动在select之后for update 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么!nnoDB将对表中的所有记录加锁，此时 就会升级为表锁。 查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from peformance_schema.data_locks; 6.3.2 Gap Lock（间隙锁） 6.3.3 Next-Key Lock（临键锁） 默认情况下，InnODB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁 。 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#gap-lock间隙锁"},{"categories":["数据库"],"content":" 6.3 行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁(GapLock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。 临键锁(Next-Key Lock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 6.3.1 Record Lock（行锁）Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分。 InnoDB实现了以下两种类型的行锁： 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 S(共享锁) X(排他锁) S(共享锁) 兼容 冲突 X(排他锁) 冲突 冲突 行锁类型： SQL 行锁类型 说明 insert，update，delete … 排他锁 自动加锁 select 不加任何锁 select … lock in share mode 共享锁 需要手动select之后加上lock in share mode select … for update 排他锁 需要手动在select之后for update 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。 InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么!nnoDB将对表中的所有记录加锁，此时 就会升级为表锁。 查看意向锁及行锁的加锁情况： select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from peformance_schema.data_locks; 6.3.2 Gap Lock（间隙锁） 6.3.3 Next-Key Lock（临键锁） 默认情况下，InnODB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。 索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁 。 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock退化为间隙锁。 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#next-key-lock临键锁"},{"categories":["数据库"],"content":" 7 InnoDB引擎","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#innodb引擎"},{"categories":["数据库"],"content":" 7.1 逻辑存储结构 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#逻辑存储结构"},{"categories":["数据库"],"content":" 7.2 架构 7.2.1 内存架构 7.2.2 磁盘结构 7.2.3 后台线程 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#架构"},{"categories":["数据库"],"content":" 7.2 架构 7.2.1 内存架构 7.2.2 磁盘结构 7.2.3 后台线程 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#内存架构"},{"categories":["数据库"],"content":" 7.2 架构 7.2.1 内存架构 7.2.2 磁盘结构 7.2.3 后台线程 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#磁盘结构"},{"categories":["数据库"],"content":" 7.2 架构 7.2.1 内存架构 7.2.2 磁盘结构 7.2.3 后台线程 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#后台线程"},{"categories":["数据库"],"content":" 7.3 事务原理事务： 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 特征： 原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性(Consistency) ：事务完成时，必须使所有的数据都保持一致状态。 隔离性(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 特性原理分类图： 7.3.1 redo log重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 该日志文件由两部分组成:重做日志缓冲(redo log buffer)以及重做日志文件(redo log file),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。 Buffer Pool在产生脏页数据的时候，会先将数据存储到 redo log buffer 再存储到 redo log 中进行磁盘持久化存储，在内存出现异常（比如突然断电）时，通过redo log中持久化的数据进行回滚。过程如下图： redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举? 写入 redo log 的方式使用了追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。 7.3.2 undo log回滚日志，用于记录数据被修改前的信息，作用包含两个:提供回滚 和 MVCC(多版本并发控制)。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。 Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除undol0g，因为这些日志可能还用于 MVCC。 Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个 undo log segment. ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#事务原理"},{"categories":["数据库"],"content":" 7.3 事务原理事务： 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 特征： 原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性(Consistency) ：事务完成时，必须使所有的数据都保持一致状态。 隔离性(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 特性原理分类图： 7.3.1 redo log重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 该日志文件由两部分组成:重做日志缓冲(redo log buffer)以及重做日志文件(redo log file),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。 Buffer Pool在产生脏页数据的时候，会先将数据存储到 redo log buffer 再存储到 redo log 中进行磁盘持久化存储，在内存出现异常（比如突然断电）时，通过redo log中持久化的数据进行回滚。过程如下图： redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举? 写入 redo log 的方式使用了追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。 7.3.2 undo log回滚日志，用于记录数据被修改前的信息，作用包含两个:提供回滚 和 MVCC(多版本并发控制)。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。 Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除undol0g，因为这些日志可能还用于 MVCC。 Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个 undo log segment. ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#redo-log"},{"categories":["数据库"],"content":" 7.3 事务原理事务： 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 特征： 原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性(Consistency) ：事务完成时，必须使所有的数据都保持一致状态。 隔离性(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 特性原理分类图： 7.3.1 redo log重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 该日志文件由两部分组成:重做日志缓冲(redo log buffer)以及重做日志文件(redo log file),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。 Buffer Pool在产生脏页数据的时候，会先将数据存储到 redo log buffer 再存储到 redo log 中进行磁盘持久化存储，在内存出现异常（比如突然断电）时，通过redo log中持久化的数据进行回滚。过程如下图： redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举? 写入 redo log 的方式使用了追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。 7.3.2 undo log回滚日志，用于记录数据被修改前的信息，作用包含两个:提供回滚 和 MVCC(多版本并发控制)。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。 Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除undol0g，因为这些日志可能还用于 MVCC。 Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个 undo log segment. ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#undo-log"},{"categories":["数据库"],"content":" 7.4 MVCC当前读： 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select…lock in share mode(共享锁)，select… for update、update、insert、delete(排他锁)都是一种当前读。 快照读： 简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 Read committed:每次select，都生成一个快照读。 Repeatable Read:开启事务后第一个select语句才是快照读的地方。 Serializable:快照读会退化为当前读。 MVCC： 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MVSOL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、read View。 7.4.1 三个隐藏字段 7.4.2 undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undoloq日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 那么何时删除？ 事务提交后： 对于INSERT操作，事务提交后，undo log可以被立即删除，因为不再需要用于回滚。 对于UPDATE和DELETE操作，undo log不会立即被删除，因为它们可能在后续的快照读取中被使用。 快照读取结束： 当所有依赖于该undo log的快照读取操作结束后，undo log才会被删除。这意味着如果有一个事务正在进行快照读取，并且依赖于某个undo log，那么这个undo log会一直保留直到该事务结束。 7.4.3 readviewReadView(读视图)是 快照读 SOL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。 ReadView中包含了四个核心字段: 字段 含义 m_ids 当前活跃的事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） creator_trx_id ReadView创建者的事务ID 依次比较 undo log 日志中版本数据链，找到可以进行访问的版本数据。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mvcc"},{"categories":["数据库"],"content":" 7.4 MVCC当前读： 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select…lock in share mode(共享锁)，select… for update、update、insert、delete(排他锁)都是一种当前读。 快照读： 简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 Read committed:每次select，都生成一个快照读。 Repeatable Read:开启事务后第一个select语句才是快照读的地方。 Serializable:快照读会退化为当前读。 MVCC： 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MVSOL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、read View。 7.4.1 三个隐藏字段 7.4.2 undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undoloq日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 那么何时删除？ 事务提交后： 对于INSERT操作，事务提交后，undo log可以被立即删除，因为不再需要用于回滚。 对于UPDATE和DELETE操作，undo log不会立即被删除，因为它们可能在后续的快照读取中被使用。 快照读取结束： 当所有依赖于该undo log的快照读取操作结束后，undo log才会被删除。这意味着如果有一个事务正在进行快照读取，并且依赖于某个undo log，那么这个undo log会一直保留直到该事务结束。 7.4.3 readviewReadView(读视图)是 快照读 SOL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。 ReadView中包含了四个核心字段: 字段 含义 m_ids 当前活跃的事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） creator_trx_id ReadView创建者的事务ID 依次比较 undo log 日志中版本数据链，找到可以进行访问的版本数据。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#三个隐藏字段"},{"categories":["数据库"],"content":" 7.4 MVCC当前读： 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select…lock in share mode(共享锁)，select… for update、update、insert、delete(排他锁)都是一种当前读。 快照读： 简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 Read committed:每次select，都生成一个快照读。 Repeatable Read:开启事务后第一个select语句才是快照读的地方。 Serializable:快照读会退化为当前读。 MVCC： 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MVSOL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、read View。 7.4.1 三个隐藏字段 7.4.2 undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undoloq日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 那么何时删除？ 事务提交后： 对于INSERT操作，事务提交后，undo log可以被立即删除，因为不再需要用于回滚。 对于UPDATE和DELETE操作，undo log不会立即被删除，因为它们可能在后续的快照读取中被使用。 快照读取结束： 当所有依赖于该undo log的快照读取操作结束后，undo log才会被删除。这意味着如果有一个事务正在进行快照读取，并且依赖于某个undo log，那么这个undo log会一直保留直到该事务结束。 7.4.3 readviewReadView(读视图)是 快照读 SOL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。 ReadView中包含了四个核心字段: 字段 含义 m_ids 当前活跃的事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） creator_trx_id ReadView创建者的事务ID 依次比较 undo log 日志中版本数据链，找到可以进行访问的版本数据。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#undo-log-1"},{"categories":["数据库"],"content":" 7.4 MVCC当前读： 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select…lock in share mode(共享锁)，select… for update、update、insert、delete(排他锁)都是一种当前读。 快照读： 简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 Read committed:每次select，都生成一个快照读。 Repeatable Read:开启事务后第一个select语句才是快照读的地方。 Serializable:快照读会退化为当前读。 MVCC： 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MVSOL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、read View。 7.4.1 三个隐藏字段 7.4.2 undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undoloq日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 那么何时删除？ 事务提交后： 对于INSERT操作，事务提交后，undo log可以被立即删除，因为不再需要用于回滚。 对于UPDATE和DELETE操作，undo log不会立即被删除，因为它们可能在后续的快照读取中被使用。 快照读取结束： 当所有依赖于该undo log的快照读取操作结束后，undo log才会被删除。这意味着如果有一个事务正在进行快照读取，并且依赖于某个undo log，那么这个undo log会一直保留直到该事务结束。 7.4.3 readviewReadView(读视图)是 快照读 SOL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。 ReadView中包含了四个核心字段: 字段 含义 m_ids 当前活跃的事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的） creator_trx_id ReadView创建者的事务ID 依次比较 undo log 日志中版本数据链，找到可以进行访问的版本数据。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#readview"},{"categories":["数据库"],"content":" 8 MySQL管理","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysql管理"},{"categories":["数据库"],"content":" 8.1 系统数据库介绍Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下： 数据库 含义 mysql 存储MVSQL服务器正常运行所需要的各种信息(时区、主从、用户、权限等) information_schema 提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等 performance_schema 为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数 sys 包含了一系列方便 DBA和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#系统数据库介绍"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#常用工具"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysql"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysqladmin"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysqlbinlog"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysqlshow"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysqldump"},{"categories":["数据库"],"content":" 8.2 常用工具 8.2.1 mysql 8.2.2 mysqladmin 8.2.3 mysqlbinlog 8.2.4 mysqlshow 8.2.5 mysqldump 8.2.6 mysqlimport/source ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mysqlimportsource"},{"categories":["数据库"],"content":" 运维篇","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#运维篇"},{"categories":["数据库"],"content":" 1 日志","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日志"},{"categories":["数据库"],"content":" 1.1 错误日志错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。 该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志位置： show variables like '%log_error%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#错误日志"},{"categories":["数据库"],"content":" 1.2 二进制日志 1.2.1 介绍二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。 作用： 灾难时的数据恢复； MySQL的主从复制。 在MVSOL8版本中，默认二进制日志是开启着的，涉及到的参数如下： show variables like '%log_bin%' 1.2.2 日志格式MySQL服务器中提供了多种格式来记录二进制记录，具体格式及特点如下： 日志格式 含义 statement 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。 row 基于行的日志记录，记录的是每一行的数据变更。(默认) mined 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。 查看参数方式：show variables like '%binlog_format%'; 1.2.3 日志查看由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法： mysql mysqlbinlog[参数选项]logfilename 参数选项： -d 指定数据库名称，只列出指定的数据库相关的操作。 -o 忽略掉日志中的前n行命令。 -v 将行事件(数据变更)重构为SOL语句。 -w 将行事件(数据变更)重构为SQL语句，并输出注释信息 1.2.4 日志删除对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志： 指令 含义 reset master 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始 purge master logs to ‘binlog.***’ 删除 *** 编号之前的所有日志 purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ 删除日志为\"yyyy-mm-dd hh24:mi:ss\"之前产生的所有日志 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除. show variables like '%binlog_expire_logs_seconds%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#二进制日志"},{"categories":["数据库"],"content":" 1.2 二进制日志 1.2.1 介绍二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。 作用： 灾难时的数据恢复； MySQL的主从复制。 在MVSOL8版本中，默认二进制日志是开启着的，涉及到的参数如下： show variables like '%log_bin%' 1.2.2 日志格式MySQL服务器中提供了多种格式来记录二进制记录，具体格式及特点如下： 日志格式 含义 statement 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。 row 基于行的日志记录，记录的是每一行的数据变更。(默认) mined 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。 查看参数方式：show variables like '%binlog_format%'; 1.2.3 日志查看由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法： mysql mysqlbinlog[参数选项]logfilename 参数选项： -d 指定数据库名称，只列出指定的数据库相关的操作。 -o 忽略掉日志中的前n行命令。 -v 将行事件(数据变更)重构为SOL语句。 -w 将行事件(数据变更)重构为SQL语句，并输出注释信息 1.2.4 日志删除对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志： 指令 含义 reset master 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始 purge master logs to ‘binlog.***’ 删除 *** 编号之前的所有日志 purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ 删除日志为\"yyyy-mm-dd hh24:mi:ss\"之前产生的所有日志 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除. show variables like '%binlog_expire_logs_seconds%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#介绍"},{"categories":["数据库"],"content":" 1.2 二进制日志 1.2.1 介绍二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。 作用： 灾难时的数据恢复； MySQL的主从复制。 在MVSOL8版本中，默认二进制日志是开启着的，涉及到的参数如下： show variables like '%log_bin%' 1.2.2 日志格式MySQL服务器中提供了多种格式来记录二进制记录，具体格式及特点如下： 日志格式 含义 statement 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。 row 基于行的日志记录，记录的是每一行的数据变更。(默认) mined 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。 查看参数方式：show variables like '%binlog_format%'; 1.2.3 日志查看由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法： mysql mysqlbinlog[参数选项]logfilename 参数选项： -d 指定数据库名称，只列出指定的数据库相关的操作。 -o 忽略掉日志中的前n行命令。 -v 将行事件(数据变更)重构为SOL语句。 -w 将行事件(数据变更)重构为SQL语句，并输出注释信息 1.2.4 日志删除对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志： 指令 含义 reset master 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始 purge master logs to ‘binlog.***’ 删除 *** 编号之前的所有日志 purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ 删除日志为\"yyyy-mm-dd hh24:mi:ss\"之前产生的所有日志 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除. show variables like '%binlog_expire_logs_seconds%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日志格式"},{"categories":["数据库"],"content":" 1.2 二进制日志 1.2.1 介绍二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。 作用： 灾难时的数据恢复； MySQL的主从复制。 在MVSOL8版本中，默认二进制日志是开启着的，涉及到的参数如下： show variables like '%log_bin%' 1.2.2 日志格式MySQL服务器中提供了多种格式来记录二进制记录，具体格式及特点如下： 日志格式 含义 statement 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。 row 基于行的日志记录，记录的是每一行的数据变更。(默认) mined 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。 查看参数方式：show variables like '%binlog_format%'; 1.2.3 日志查看由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法： mysql mysqlbinlog[参数选项]logfilename 参数选项： -d 指定数据库名称，只列出指定的数据库相关的操作。 -o 忽略掉日志中的前n行命令。 -v 将行事件(数据变更)重构为SOL语句。 -w 将行事件(数据变更)重构为SQL语句，并输出注释信息 1.2.4 日志删除对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志： 指令 含义 reset master 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始 purge master logs to ‘binlog.***’ 删除 *** 编号之前的所有日志 purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ 删除日志为\"yyyy-mm-dd hh24:mi:ss\"之前产生的所有日志 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除. show variables like '%binlog_expire_logs_seconds%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日志查看"},{"categories":["数据库"],"content":" 1.2 二进制日志 1.2.1 介绍二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。 作用： 灾难时的数据恢复； MySQL的主从复制。 在MVSOL8版本中，默认二进制日志是开启着的，涉及到的参数如下： show variables like '%log_bin%' 1.2.2 日志格式MySQL服务器中提供了多种格式来记录二进制记录，具体格式及特点如下： 日志格式 含义 statement 基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。 row 基于行的日志记录，记录的是每一行的数据变更。(默认) mined 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。 查看参数方式：show variables like '%binlog_format%'; 1.2.3 日志查看由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法： mysql mysqlbinlog[参数选项]logfilename 参数选项： -d 指定数据库名称，只列出指定的数据库相关的操作。 -o 忽略掉日志中的前n行命令。 -v 将行事件(数据变更)重构为SOL语句。 -w 将行事件(数据变更)重构为SQL语句，并输出注释信息 1.2.4 日志删除对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志： 指令 含义 reset master 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始 purge master logs to ‘binlog.***’ 删除 *** 编号之前的所有日志 purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ 删除日志为\"yyyy-mm-dd hh24:mi:ss\"之前产生的所有日志 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除. show variables like '%binlog_expire_logs_seconds%' ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日志删除"},{"categories":["数据库"],"content":" 1.3 查询日志查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置一下配置： 修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容： mysql #该选项用来开启查询日志，可选值：0或者1；0代表关闭，1代表开启 general_log=1 #设置日志的文件名 ， 如果没有指定，默认的文件名为 host_name.log general_log_file=mysql_query.log ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#查询日志"},{"categories":["数据库"],"content":" 1.4 慢查询日志慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为0，精度可以到微秒。 sql #慢查询日志 slow_query_log=1 #执行时间参数 long_query_time=2 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用log_slow_admin_statements和更改此行为log_queries_not_using_indexes，如下所述。 sql #记录执行较慢的管理语句 log_slow_admin_statements = 1 #记录执行较慢的未使用索引的语句 log_queries_not_using_indexes = 1 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#慢查询日志-1"},{"categories":["数据库"],"content":" 2 主从复制 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#主从复制"},{"categories":["数据库"],"content":" 2.1 原理 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#原理"},{"categories":["数据库"],"content":" 2.2 搭建实现 2.2.1 主库配置 2.2.2 从库配置 2.2.3 测试1、在主库上创建数据库、表，并插入数据 sql create database db01; use db01; create table tb_use( id int(11) primary key not null auto_increment, name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id, name, sex) valurs (null, 'Tom', '1'), (null, 'Trigger', '0'), (null, 'Dawn', '1'); 2、在从库中查询数据，验证主从是否同步。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#搭建实现"},{"categories":["数据库"],"content":" 2.2 搭建实现 2.2.1 主库配置 2.2.2 从库配置 2.2.3 测试1、在主库上创建数据库、表，并插入数据 sql create database db01; use db01; create table tb_use( id int(11) primary key not null auto_increment, name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id, name, sex) valurs (null, 'Tom', '1'), (null, 'Trigger', '0'), (null, 'Dawn', '1'); 2、在从库中查询数据，验证主从是否同步。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#主库配置"},{"categories":["数据库"],"content":" 2.2 搭建实现 2.2.1 主库配置 2.2.2 从库配置 2.2.3 测试1、在主库上创建数据库、表，并插入数据 sql create database db01; use db01; create table tb_use( id int(11) primary key not null auto_increment, name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id, name, sex) valurs (null, 'Tom', '1'), (null, 'Trigger', '0'), (null, 'Dawn', '1'); 2、在从库中查询数据，验证主从是否同步。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#从库配置"},{"categories":["数据库"],"content":" 2.2 搭建实现 2.2.1 主库配置 2.2.2 从库配置 2.2.3 测试1、在主库上创建数据库、表，并插入数据 sql create database db01; use db01; create table tb_use( id int(11) primary key not null auto_increment, name varchar(50) not null, sex varchar(1) )engine=innodb default charset=utf8mb4; insert into tb_user(id, name, sex) valurs (null, 'Tom', '1'), (null, 'Trigger', '0'), (null, 'Dawn', '1'); 2、在从库中查询数据，验证主从是否同步。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#测试"},{"categories":["数据库"],"content":" 3 分库分表","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#分库分表"},{"categories":["数据库"],"content":" 3.1 介绍 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#介绍-1"},{"categories":["数据库"],"content":" 3.2 Mycat概述 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mycat概述"},{"categories":["数据库"],"content":" 3.3 Mycat入门 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mycat入门"},{"categories":["数据库"],"content":" 3.4 Mycat配置 3.4.1 schema.xmlschema.xml作为MyCat中最重要的配置文件之一,涵盖了MyCat的逻辑库 、逻辑表 、分片规则、分片节点及数据源的配置. 主要包含以下三组标签: schema标签 datanode标签 datahost标签 3.4.2 rule.xml ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mycat配置"},{"categories":["数据库"],"content":" 3.4 Mycat配置 3.4.1 schema.xmlschema.xml作为MyCat中最重要的配置文件之一,涵盖了MyCat的逻辑库 、逻辑表 、分片规则、分片节点及数据源的配置. 主要包含以下三组标签: schema标签 datanode标签 datahost标签 3.4.2 rule.xml ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#schemaxml"},{"categories":["数据库"],"content":" 3.4 Mycat配置 3.4.1 schema.xmlschema.xml作为MyCat中最重要的配置文件之一,涵盖了MyCat的逻辑库 、逻辑表 、分片规则、分片节点及数据源的配置. 主要包含以下三组标签: schema标签 datanode标签 datahost标签 3.4.2 rule.xml ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#rulexml"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mycat分片"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#垂直分库"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#水平分表"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#分片规则"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#范围分片"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#取模分片"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#一致性hash算法"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#枚举分片"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#应用指定算法"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#固定hash算法"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#字符串hash解析"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#按天分片"},{"categories":["数据库"],"content":" 3.5 Mycat分片 3.5.1 垂直分库 3.5.2 水平分表 3.5.3 分片规则 3.5.3.1 范围分片 3.5.3.2 取模分片 3.5.3.3 一致性hash算法 3.5.3.4 枚举分片 3.5.3.5 应用指定算法 3.5.3.6 固定hash算法 3.5.3.7 字符串hash解析 3.5.3.8 按天分片 3.5.3.9 按自然月分片 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#按自然月分片"},{"categories":["数据库"],"content":" 3.6 Mycat管理及监控 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:6","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#mycat管理及监控"},{"categories":["数据库"],"content":" 4 读写分离 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#读写分离"},{"categories":["数据库"],"content":" 4.1 介绍 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#介绍-2"},{"categories":["数据库"],"content":" 4.2 一主一从读写分离 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#一主一从读写分离"},{"categories":["数据库"],"content":" 4.3 双主双从 测试： 分别在两台主库Master1、Master2上执行DDL、DML语句，查看涉及到的数据库服务器的数据同步情况。 text create database db01; use db01; create table tb_user( id in(11)not null primary key, name varchar(50) not null, sex varcahr(1) )engine=innodb default charset=utf8mb4 insert into tb user(id,name,sex) values(l,'Tom','1'); insert into tb user(id,name,sex) values(2,'Trigger','0'); insert into tb user(id,name,sex) values(3,'Dawn','1'); insert into tb user(id,name,sex) values(4,\"ack Ma','1'); insertinto tb user(id,name,sex) values(5,'Coco','0'); insert into tb user(id,name,sex) values(6,'erry','1'); ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#双主双从"},{"categories":["数据库"],"content":" 4.4 双主双从读写分离 测试： 登录MyCat，测试查询及更新操作，判定是否能够进行读写分离，以及读写分离的策略是否正确。 当主库挂掉一个之后，是否能够自动切换。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#双主双从读写分离"},{"categories":["数据库"],"content":" 数据类型","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#数据类型"},{"categories":["数据库"],"content":" 1 整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#整型"},{"categories":["数据库"],"content":" 2 浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#浮点型"},{"categories":["数据库"],"content":" 3 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#日期和时间"},{"categories":["数据库"],"content":" 4 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1\u003c=M\u003c=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L\u003c = M和 1\u003c=M\u003c=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L\u003c2^8 TEXT 小的非二进制字符串 L+2字节，在此，L\u003c2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L\u003c2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L\u003c2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#字符串"},{"categories":["数据库"],"content":" 5 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L\u003c2^8 BLOB (M) 小 BLOB L+2 字节，在此，L\u003c2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L\u003c2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L\u003c2^32 ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#二进制类型"},{"categories":["数据库"],"content":" 权限一览表 具体权限的作用详见 官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#权限一览表"},{"categories":["数据库"],"content":" 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/ ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#图形化界面工具"},{"categories":["数据库"],"content":" 安装","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#安装"},{"categories":["数据库"],"content":" 小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间： mysql SELECT table_schema \"Database Name\" , SUM(data_length + index_length) / (1024 * 1024) \"Database Size in MB\" FROM information_schema.TABLES GROUP BY table_schema; ","date":"2025-04-24","objectID":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":null,"title":"MySQL学习笔记","uri":"/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#小技巧"},{"categories":["Golang"],"content":"GC使用的方法是并发三色标记加上混合写屏障 ","date":"2025-04-24","objectID":"/gc/:0:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#"},{"categories":["Golang"],"content":" 1 1. GC触发条件 堆内存增长：当堆内存使用量达到上次GC后的2倍时触发(默认配置为100%) 定时触发：默认2分钟强制触发一次GC 手动触发：调用runtime.GC() ","date":"2025-04-24","objectID":"/gc/:1:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#1-gc触发条件"},{"categories":["Golang"],"content":" 2 2. 三色标记算法Go使用三色并发标记清除算法： 白色：未被访问的对象，GC结束后没有变色会被回收 灰色：已被访问, 但其引用对象还未扫描完的对象 黑色：已被访问 , 且其所有引用对象都已扫描的对象 ","date":"2025-04-24","objectID":"/gc/:2:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#2-三色标记算法"},{"categories":["Golang"],"content":" 3 3. GC执行流程","date":"2025-04-24","objectID":"/gc/:3:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#3-gc执行流程"},{"categories":["Golang"],"content":" 3.1 Phase 1: Mark Setup (STW) 停止所有goroutine（Stop The World） 启动后台标记工作goroutine 将根对象（全局变量、栈变量等）标记为灰色 ","date":"2025-04-24","objectID":"/gc/:3:1","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#phase-1-mark-setup-stw"},{"categories":["Golang"],"content":" 3.2 Phase 2: Concurrent Mark 恢复用户程序执行 后台goroutine并发标记： 从灰色对象队列中取出对象 将其引用的白色对象标记为灰色 将当前对象标记为黑色 使用写屏障保证并发安全 写屏障包含插入写屏障和删除写屏障 插入写屏障（Dijkstra）的目标是实现强三色不变式，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用. 删除写屏障（Yuasa barrier）的目标是实现弱三色不变式，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用. 屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容. • 堆对象正常启用插入写屏障 • 堆对象正常启用删除写屏障 屏障机制无法作用于栈对象. GC期间新分配的对象会直接设置为黑色 ","date":"2025-04-24","objectID":"/gc/:3:2","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#phase-2-concurrent-mark"},{"categories":["Golang"],"content":" 3.3 Phase 3: Mark Termination (STW)会遍历释放所有P的写屏障缓存，查看是否存在因屏障机制遗留的灰色对象，如果有，则会推出gcMarkDone方法，回退到gcBgMarkWorker的主循环中，继续完成标记任务. 倘若写屏障中也没有遗留的灰对象，此时会调用STW停止世界，并步入gcMarkTermination方法进入标记终止阶段. 再次停止所有goroutine 完成剩余的标记工作 清理写屏障 ","date":"2025-04-24","objectID":"/gc/:3:3","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#phase-3-mark-termination-stw"},{"categories":["Golang"],"content":" 3.4 Phase 4: Sweep 并发清除所有白色对象 回收内存空间 ","date":"2025-04-24","objectID":"/gc/:3:4","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#phase-4-sweep"},{"categories":["Golang"],"content":" GC 优化 0.4.1 GOGC：核心调优参数GOGC 是控制 GC 频率最重要的环境变量。它的默认值是 100。 它的含义是：当新分配的内存达到上次 GC 结束后存活内存的 GOGC% 时，触发下一次 GC。 GOGC = 100 (默认): 意味着当堆内存增长到上一次的两倍时，触发 GC。这是一个在 CPU 开销和内存占用之间的平衡选择。 GOGC \u003c 100: 会让 GC 更频繁地触发。这会增加 CPU 的消耗，但能更有效地控制内存占用，适合内存敏感的应用。 GOGC \u003e 100: 会让 GC 不那么频繁。这会减少 CPU 的消耗，但会允许程序占用更多内存。 GOGC = off: 关闭 GC。极不推荐，除非是短时运行、内存占用明确的特殊程序。 你也可以在代码中通过 debug.SetGCPercent() 来动态设置。 0.4.2 GOMEMLIMIT：软内存限制从 Go 1.19 开始，引入了 GOMEMLIMIT 环境变量。它提供了一个软内存限制。当程序的总内存使用接近这个限制时，GC 会被更积极地触发，以尝试将内存维持在这个限制之下。这对于在有严格内存限制的容器环境中运行 Go 程序非常有用。 0.4.3 优化方法 内存分配优化：最高效的 GC 就是不发生 GC。通过优化代码，减少不必要的临时对象分配，是性能调优的第一步。 可以使用 sync.Pool 来复用对象。 尽量预分配内存，减少动态扩容 避免指针：减少指针数量可降低GC扫描成本，GC 只关心指针指向的对象。如果你的数据结构中不包含指针（或 slice, map, chan 等），GC 的扫描工作量就会大大减少。 合理设置 GOGC：通过性能分析（pprof），观察应用的 GC 行为和内存增长情况，调整 GOGC 以在 CPU 和内存之间找到最佳平衡点。 ","date":"2025-04-24","objectID":"/gc/:0:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#gc-优化"},{"categories":["Golang"],"content":" GC 优化 0.4.1 GOGC：核心调优参数GOGC 是控制 GC 频率最重要的环境变量。它的默认值是 100。 它的含义是：当新分配的内存达到上次 GC 结束后存活内存的 GOGC% 时，触发下一次 GC。 GOGC = 100 (默认): 意味着当堆内存增长到上一次的两倍时，触发 GC。这是一个在 CPU 开销和内存占用之间的平衡选择。 GOGC \u003c 100: 会让 GC 更频繁地触发。这会增加 CPU 的消耗，但能更有效地控制内存占用，适合内存敏感的应用。 GOGC \u003e 100: 会让 GC 不那么频繁。这会减少 CPU 的消耗，但会允许程序占用更多内存。 GOGC = off: 关闭 GC。极不推荐，除非是短时运行、内存占用明确的特殊程序。 你也可以在代码中通过 debug.SetGCPercent() 来动态设置。 0.4.2 GOMEMLIMIT：软内存限制从 Go 1.19 开始，引入了 GOMEMLIMIT 环境变量。它提供了一个软内存限制。当程序的总内存使用接近这个限制时，GC 会被更积极地触发，以尝试将内存维持在这个限制之下。这对于在有严格内存限制的容器环境中运行 Go 程序非常有用。 0.4.3 优化方法 内存分配优化：最高效的 GC 就是不发生 GC。通过优化代码，减少不必要的临时对象分配，是性能调优的第一步。 可以使用 sync.Pool 来复用对象。 尽量预分配内存，减少动态扩容 避免指针：减少指针数量可降低GC扫描成本，GC 只关心指针指向的对象。如果你的数据结构中不包含指针（或 slice, map, chan 等），GC 的扫描工作量就会大大减少。 合理设置 GOGC：通过性能分析（pprof），观察应用的 GC 行为和内存增长情况，调整 GOGC 以在 CPU 和内存之间找到最佳平衡点。 ","date":"2025-04-24","objectID":"/gc/:0:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#gogc核心调优参数"},{"categories":["Golang"],"content":" GC 优化 0.4.1 GOGC：核心调优参数GOGC 是控制 GC 频率最重要的环境变量。它的默认值是 100。 它的含义是：当新分配的内存达到上次 GC 结束后存活内存的 GOGC% 时，触发下一次 GC。 GOGC = 100 (默认): 意味着当堆内存增长到上一次的两倍时，触发 GC。这是一个在 CPU 开销和内存占用之间的平衡选择。 GOGC \u003c 100: 会让 GC 更频繁地触发。这会增加 CPU 的消耗，但能更有效地控制内存占用，适合内存敏感的应用。 GOGC \u003e 100: 会让 GC 不那么频繁。这会减少 CPU 的消耗，但会允许程序占用更多内存。 GOGC = off: 关闭 GC。极不推荐，除非是短时运行、内存占用明确的特殊程序。 你也可以在代码中通过 debug.SetGCPercent() 来动态设置。 0.4.2 GOMEMLIMIT：软内存限制从 Go 1.19 开始，引入了 GOMEMLIMIT 环境变量。它提供了一个软内存限制。当程序的总内存使用接近这个限制时，GC 会被更积极地触发，以尝试将内存维持在这个限制之下。这对于在有严格内存限制的容器环境中运行 Go 程序非常有用。 0.4.3 优化方法 内存分配优化：最高效的 GC 就是不发生 GC。通过优化代码，减少不必要的临时对象分配，是性能调优的第一步。 可以使用 sync.Pool 来复用对象。 尽量预分配内存，减少动态扩容 避免指针：减少指针数量可降低GC扫描成本，GC 只关心指针指向的对象。如果你的数据结构中不包含指针（或 slice, map, chan 等），GC 的扫描工作量就会大大减少。 合理设置 GOGC：通过性能分析（pprof），观察应用的 GC 行为和内存增长情况，调整 GOGC 以在 CPU 和内存之间找到最佳平衡点。 ","date":"2025-04-24","objectID":"/gc/:0:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#gomemlimit软内存限制"},{"categories":["Golang"],"content":" GC 优化 0.4.1 GOGC：核心调优参数GOGC 是控制 GC 频率最重要的环境变量。它的默认值是 100。 它的含义是：当新分配的内存达到上次 GC 结束后存活内存的 GOGC% 时，触发下一次 GC。 GOGC = 100 (默认): 意味着当堆内存增长到上一次的两倍时，触发 GC。这是一个在 CPU 开销和内存占用之间的平衡选择。 GOGC \u003c 100: 会让 GC 更频繁地触发。这会增加 CPU 的消耗，但能更有效地控制内存占用，适合内存敏感的应用。 GOGC \u003e 100: 会让 GC 不那么频繁。这会减少 CPU 的消耗，但会允许程序占用更多内存。 GOGC = off: 关闭 GC。极不推荐，除非是短时运行、内存占用明确的特殊程序。 你也可以在代码中通过 debug.SetGCPercent() 来动态设置。 0.4.2 GOMEMLIMIT：软内存限制从 Go 1.19 开始，引入了 GOMEMLIMIT 环境变量。它提供了一个软内存限制。当程序的总内存使用接近这个限制时，GC 会被更积极地触发，以尝试将内存维持在这个限制之下。这对于在有严格内存限制的容器环境中运行 Go 程序非常有用。 0.4.3 优化方法 内存分配优化：最高效的 GC 就是不发生 GC。通过优化代码，减少不必要的临时对象分配，是性能调优的第一步。 可以使用 sync.Pool 来复用对象。 尽量预分配内存，减少动态扩容 避免指针：减少指针数量可降低GC扫描成本，GC 只关心指针指向的对象。如果你的数据结构中不包含指针（或 slice, map, chan 等），GC 的扫描工作量就会大大减少。 合理设置 GOGC：通过性能分析（pprof），观察应用的 GC 行为和内存增长情况，调整 GOGC 以在 CPU 和内存之间找到最佳平衡点。 ","date":"2025-04-24","objectID":"/gc/:0:0","series":null,"tags":null,"title":"golang 垃圾回收","uri":"/gc/#优化方法"},{"categories":["BT","KRPC"],"content":"所有的 KRPC 消息都是通过 UDP 传输的、经过 Bencode 编码的字典。 本文主要介绍find_node、 get_peers 和 announce_peer 这三个 RPC 调用的请求和响应消息结构。 通用结构元素: t: 事务 ID (Transaction ID)，二进制字符串，由请求方设置，响应方必须在响应中原样返回。 y: 消息类型 (Message Type)，单个字符，‘q’ 代表查询 (Query)，‘r’ 代表响应 (Response)，’e’ 代表错误 (Error)。 v (可选): 客户端版本信息 (Version)，通常是字符串。 ip (可选，通常在响应中出现): 响应者看到的请求者的公网 IP 地址和端口 (紧凑的 6 字节二进制字符串)。 ","date":"2025-04-20","objectID":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC请求格式","uri":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/#"},{"categories":["BT","KRPC"],"content":" 0.1 1、find_node RPC目的: 向一个节点请求，获取它所知道的、其 Node ID 在 XOR 距离上最接近指定 target Node ID 的 k 个节点的联系信息。这主要用于路由表的填充和更新，以及在其他查找（如 get_peers）中进行迭代查询。 find_node 请求用于询问某个节点：“请告诉我你认识的、离 target 这个 Node ID 最近的那些节点是谁？”。响应则直接返回一个包含这些节点（最多 k 个）联系信息的紧凑字符串。这个 RPC 是 DHT 网络进行节点发现和路由的基础。 A. find_node 请求结构 (y = ‘q’) JSON { \"t\": \"\u003ctransaction_id\u003e\", // 请求者的事务 ID (二进制字符串) \"y\": \"q\", // 类型：查询 \"q\": \"find_node\", // 查询方法名 (字符串) \"a\": { // 参数字典 \"id\": \"\u003crequester_node_id\u003e\", // 请求者自身的 Node ID (20 字节二进制字符串) \"target\": \"\u003ctarget_node_id\u003e\" // 查找的目标 Node ID (20 字节二进制字符串) } // \"v\": \"\u003crequester_version\u003e\" // 可选：请求者客户端版本 } 请求参数 (a 字典) 详解: id: 发起请求的节点的 Node ID。接收节点可以用这个 ID 来更新自己的路由表（K-桶）。 target: 查找的目标节点的 Node ID。接收节点需要返回其路由表中，节点 ID 与这个 target 值在 XOR 距离上最接近的节点列表。 B. find_node 响应结构 (y = ‘r’) JSON JSON { \"t\": \"\u003ctransaction_id\u003e\", // 与请求中相同的事务 ID \"y\": \"r\", // 类型：响应 \"r\": { // 返回值字典 \"id\": \"\u003cresponder_node_id\u003e\", // 响应节点的 Node ID (20 字节二进制字符串) \"nodes\": \"\u003ccompact_node_info_string\u003e\" // 包含 k 个最接近 target 的节点信息的字符串 } // \"ip\": \"\u003crequester_ip_port\u003e\" // 可选：响应者看到的请求者的 IP/端口 // \"v\": \"\u003cresponder_version\u003e\" // 可选：响应者客户端版本 } 响应参数 (r 字典) 详解: id: 响应这个 find_node 请求的节点的 Node ID。 nodes: 一个二进制字符串，包含了响应节点所知道的、最接近 target Node ID 的 k 个节点的紧凑节点信息 (Compact Node Info)。 这个字符串是由多个 26 字节 的块连接而成的。 每个 26 字节块代表一个节点，其结构为： 前 20 字节: 节点的 Node ID (网络字节序/Big-Endian) 接下来 4 字节: 节点的 IPv4 地址 (网络字节序/Big-Endian) 最后 2 字节: 节点的端口号 (网络字节序/Big-Endian) ","date":"2025-04-20","objectID":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/:0:1","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC请求格式","uri":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/#1find_node-rpc"},{"categories":["BT","KRPC"],"content":" 0.2 2、 get_peers RPC (获取 Peer)目的: 向一个 DHT 节点询问，有哪些 Peer 正在参与分享具有特定 info-hash 的种子 (Torrent)。 A. get_peers 请求结构 (y = ‘q’) json { \"t\": \"\u003ctransaction_id\u003e\", // 请求者的事务 ID (二进制字符串) \"y\": \"q\", // 类型：查询 \"q\": \"get_peers\", // 查询方法名 (字符串) \"a\": { // 参数字典 \"id\": \"\u003crequester_node_id\u003e\", // 请求者自身的 Node ID (20 字节二进制字符串) \"info_hash\": \"\u003ctarget_info_hash\u003e\" // 目标种子的 Info-Hash (20 字节二进制字符串) - 这是查找的 KEY } // \"v\": \"\u003crequester_version\u003e\" // 可选：请求者客户端版本 } B. get_peers 响应结构 (y = ‘r’) json { \"t\": \"\u003ctransaction_id\u003e\", // 与请求中相同的事务 ID \"y\": \"r\", // 类型：响应 \"r\": { // 返回值字典 \"id\": \"\u003cresponder_node_id\u003e\", // 响应节点的 Node ID (20 字节二进制字符串) \"token\": \"\u003copaque_token\u003e\", // 一个不透明的令牌 (二进制字符串) - **非常关键**，用于后续的 announce_peer // --- 注意：下面的 'values' 或 'nodes' 字段通常只会存在一个 --- \"values\": [ // 可选：仅当响应节点存储了该 info_hash 的 Peer 信息时包含此字段 \"\u003ccompact_peer_info_1\u003e\", // 这是一个列表 (List)，每个元素是 6 字节的紧凑 Peer 信息 (IP+Port) \"\u003ccompact_peer_info_2\u003e\", // (4 字节 IP + 2 字节 Port，均为网络字节序) ... ], \"nodes\": \"\u003ccompact_node_info_string\u003e\" // 可选：仅当响应节点*没有* Peer 信息时包含此字段 // 这是一个二进制字符串，由多个 26 字节的紧凑节点信息块连接而成 // (20 字节 Node ID + 4 字节 IP + 2 字节 Port，均为网络字节序) // 代表响应者所知的、更接近目标 info_hash 的其他 DHT 节点 } // \"ip\": \"\u003crequester_ip_port\u003e\" // 可选：响应者看到的请求者的 IP/端口 // \"v\": \"\u003cresponder_version\u003e\" // 可选：响应者客户端版本 } 关键字段详解 (r 字典内部): id (必须): 类型：二进制字符串 (20 字节) 含义：响应这个 get_peers 请求的节点的 Node ID。 token (必须): 类型：二进制字符串 (通常较短) 含义：这是一个非常重要的令牌。当发起 get_peers 请求的节点（请求者）稍后想要向同一个响应节点宣告自己是该 info_hash 的 Peer 时（通过 announce_peer RPC），必须提供这个 token。接收 announce_peer 的节点会用它来验证请求的合法性，防止 DHT 污染。 values (可选，与 nodes 二选一): 类型：Bencode 列表 (List)，列表中的每个元素是二进制字符串。 含义：如果响应节点存储了与请求的 info_hash 相关联的 Peer 信息，则会包含此字段。 列表中的每个元素是一个 6 字节 的字符串，代表一个 Peer 的联系信息： 前 4 字节：Peer 的 IPv4 地址 (网络字节序/Big-Endian)。 后 2 字节：Peer 的端口号 (网络字节序/Big-Endian)。 这直接告诉了请求者可以尝试连接哪些 Peer 来下载该 Torrent。 nodes (可选，与 values 二选一): 类型：二进制字符串 含义：如果响应节点没有存储关于该 info_hash 的 Peer 信息，它会遵循 Kademlia 的 find_node 行为，返回它所知道的、其 Node ID 在 XOR 距离上最接近目标 info_hash 的 k 个节点的信息。 这个字符串是由多个 26 字节 的紧凑节点信息块连接而成的： 前 20 字节：节点的 Node ID (网络字节序)。 接下来 4 字节：节点的 IPv4 地址 (网络字节序)。 最后 2 字节：节点的端口号 (网络字节序)。 收到这个字段意味着请求者需要继续向这些返回的“更近”的节点发送 get_peers 请求，以继续查找 Peer。 ","date":"2025-04-20","objectID":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/:0:2","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC请求格式","uri":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/#2-get_peers-rpc-获取-peer"},{"categories":["BT","KRPC"],"content":" 0.3 3、 announce_peer RPC (宣告 Peer)目的: 通知一个 DHT 节点（通常是其 Node ID 接近目标 info-hash 的节点），告知发送方是特定种子的一个活跃 Peer，并请求该节点存储发送方的联系信息，以便其他 Peer 可以通过 get_peers 找到它。 A. announce_peer 请求结构 (y = ‘q’) json { \"t\": \"\u003ctransaction_id\u003e\", // 请求者的事务 ID \"y\": \"q\", // 类型：查询 \"q\": \"announce_peer\", // 查询方法名 \"a\": { // 参数字典 \"id\": \"\u003cannouncer_node_id\u003e\", // 宣告者自身的 Node ID (20 字节二进制字符串) \"info_hash\": \"\u003ctarget_info_hash\u003e\", // 目标种子的 Info-Hash (20 字节二进制字符串) \"port\": \u003clistening_port\u003e, // 宣告者监听 BitTorrent 连接的端口号 (整数) \"token\": \"\u003creceived_token\u003e\", // **必须提供**：先前从**该**响应节点为**同一** info_hash 调用 `get_peers` 时收到的那个 `token` (二进制字符串) - **非常关键** \"implied_port\": \u003c0_or_1\u003e // 可选：整数 0 或 1。如果为 1，则接收方应忽略 'port' 参数，使用该 UDP 包的源端口；如果为 0 或省略，则使用 'port' 参数。 } // \"v\": \"\u003cannouncer_version\u003e\" // 可选：宣告者客户端版本 } B. announce_peer 响应结构 (y = ‘r’) 这个响应非常简单，主要是确认收到了宣告请求（如果 token 有效且没发生其他错误的话）。 json { \"t\": \"\u003ctransaction_id\u003e\", // 与请求中相同的事务 ID \"y\": \"r\", // 类型：响应 \"r\": { // 返回值字典 \"id\": \"\u003cresponder_node_id\u003e\" // 响应节点的 Node ID (20 字节二进制字符串) - 基本上就是确认收到 } // \"ip\": \"\u003cannouncer_ip_port\u003e\" // 可选：响应者看到的宣告者的 IP/端口 // \"v\": \"\u003cresponder_version\u003e\" // 可选：响应者客户端版本 } 需要注意的是: announce_peer 的成功响应 (y=‘r’) 并不绝对保证 Peer 信息已被永久存储，只表明请求已被接收且（很可能）通过了 token 验证。节点的存储行为还可能受其内部策略（如存储容量限制、速率限制等）的影响。如果发生错误（如 token 无效），则会返回错误消息 (y=‘e’)。 ","date":"2025-04-20","objectID":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC请求格式","uri":"/krpc%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F/#3-announce_peer-rpc-宣告-peer"},{"categories":["BT"],"content":"好的，我们来详细介绍一下 KRPC 协议。这是 BitTorrent Mainline DHT 网络中节点之间进行通信所使用的协议。 KRPC 是 BitTorrent DHT 的基石通信协议。它利用 UDP 的高效性和 Bencode 的简洁性，定义了一套清晰的查询/响应机制（ping, find_node, get_peers, announce_peer）以及错误处理方式 1. 基础 传输层协议: KRPC 完全构建在 UDP (User Datagram Protocol) 之上。选择 UDP 是因为它开销低、无连接，适合 P2P 网络中大量节点间的快速、短暂交互，避免了 TCP 连接管理的复杂性。 编码: 所有 KRPC 消息都使用 Bencode (B-encoding) 进行编码。这是 BitTorrent 生态系统中广泛使用的一种简单、紧凑的数据序列化格式（也用于 .torrent 文件和 Tracker 响应）。 2. 消息结构 所有 KRPC 消息都是一个 Bencode 编码的字典 (Dictionary)。这个字典包含一些通用字段，以及根据消息类型（查询、响应或错误）特定的字段。 通用字段: t: Transaction ID (事务 ID)。这是一个由查询方生成的短二进制字符串（通常 2 字节）。响应方必须在对应的响应或错误消息中原样包含这个 ID。这使得查询方能够将收到的响应与之前发出的查询匹配起来，尤其是在同时发出多个查询时。 y: Message Type (消息类型)。单个字符，表示消息的类型： 'q': Query (查询) - 由发起通信的节点发送。 'r': Response (响应) - 对成功处理的查询的回复。 'e': Error (错误) - 当无法处理查询时返回。 v (可选): Version (版本号)。表示发送者客户端的软件版本信息，通常是一个短字符串。主要用于统计和调试，协议本身不强制要求或使用它。 ip (可选, 主要在响应中): 发送者看到的请求者的公网 IP 地址和端口。这可以帮助位于 NAT 后面的节点发现自己的公网 IP。格式是紧凑的 6 字节（4 字节 IP + 2 字节 Port）。 3. 消息类型详解 a) 查询 (Query) - y = 'q' 查询消息的字典中还包含以下字段： q: Query Type (查询类型)。表示具体 RPC 方法名称的字符串。例如 \"ping\", \"find_node\", \"get_peers\", \"announce_peer\"。 a: Arguments (参数)。一个 Bencode 字典，包含该查询类型所需的所有参数。 具体的查询类型及其参数 (a 字典内容): ping: id: 发送该查询的节点的 Node ID (20 字节)。 目的: 检查目标节点是否在线，并让目标节点将查询方加入其路由表。 find_node: id: 发送查询的节点的 Node ID (20 字节)。 target: 要查找的目标 Node ID (20 字节)。 目的: 请求接收方返回其路由表中离 target ID 最近的 k 个节点的信息。 get_peers: id: 发送查询的节点的 Node ID (20 字节)。 info_hash: 目标 Torrent 的 Info-Hash (20 字节)。 目的: 请求接收方返回它所知道的正在下载/分享该 info_hash 的 Peer 列表。如果它没有 Peer 列表，则其行为应类似于 find_node，返回离 info_hash 最近的 k 个节点。 announce_peer: id: 发送查询的节点的 Node ID (20 字节)。 info_hash: 要宣告的 Torrent 的 Info-Hash (20 字节)。 port: 发送方（宣告者）监听 BitTorrent 连接的端口号 (整数)。 token: 必需。这是之前从同一接收节点处执行 get_peers 查询时收到的 token 值 (二进制字符串)。 implied_port (可选): 一个整数值 0 或 1。如果设置为 1，表示接收方应忽略消息中明确指定的 port 参数，而使用该 UDP 包的源端口作为宣告的端口。这对于位于 NAT 后面的节点，如果不确定自己的公网监听端口时很有用。 目的: 告知接收节点，发送方正在指定的端口上参与 info_hash 的 Torrent 下载/分享，请求接收节点存储这些信息以便回复给其他 get_peers 查询。 b) 响应 (Response) - y = 'r' 响应消息的字典中还包含以下字段： r: Return Values (返回值)。一个 Bencode 字典，包含查询成功执行后的结果。 具体的响应类型及其返回值 (r 字典内容): 对 ping 的响应: id: 响应节点的 Node ID (20 字节)。 对 find_node 的响应: id: 响应节点的 Node ID (20 字节)。 nodes: 一个包含紧凑节点信息 (Compact Node Info) 的字符串。包含了响应者认为离 target ID 最近的 k 个节点的信息。 对 get_peers 的响应: id: 响应节点的 Node ID (20 字节)。 token: 一个短的二进制字符串。查询方在后续向该节点发送 announce_peer 时必须提供此 token。 可能包含以下之一: values: 一个 Bencode 列表 (List)，其中每个元素是一个紧凑 Peer 信息 (Compact Peer Info) 字符串，代表一个 Peer 的 IP 和端口。 nodes: 如果响应节点没有关于该 info_hash 的 Peer 信息，则返回此字段，其格式和含义与 find_node 响应中的 nodes 字段相同。 对 announce_peer 的响应: id: 响应节点的 Node ID (20 字节)。 注意: announce_peer 的成功响应通常只包含 id，表示确认收到并（可能已）存储了宣告信息。不需要返回其他特定值。 c) 错误 (Error) - y = 'e' 错误消息的字典中还包含以下字段： e: Error Info (错误信息)。一个 Bencode 列表 (List)，包含两个元素： 第一个元素: Error Code (错误码)，一个整数。 第二个元素: Error Message (错误消息)，一个描述错误的字符串。 常见的错误码: 201: Generic Error (通用错误) 202: Server Error (服务器错误，节点内部问题) 203: Protocol Error (协议错误，如格式错误、无效参数等) 204: Method Unknown (方法未知，如请求了不支持的 RPC) 4. 紧凑节点/Peer 信息格式 (Compact Node/Peer Info) 为了节省带宽，节点和 Peer 的信息通常使用紧凑的二进制格式表示： 紧凑节点信息 (Compact Node Info): 每个节点信息是 26 字节 的字符串。 前 20 字节: Node ID (网络字节序/Big-Endian)。 接下来 4 字节: IPv4 地址 (网络字节序)。 最后 2 字节: 端口号 (网络字节序)。 nodes 字段的值就是多个这样的 26 字节块连接起来的字符串。 紧凑 Peer 信息 (Compact Peer Info): 每个 Peer 信息是 6 字节 的字符串。 前 4 字节: IPv4 地址 (网络字节序)。 后 2 字节: 端口号 (网络字节序)。 values 字段的值是 Bencode 列表，列表中的每个元素是这样一个 6 字节的字符串。 ","date":"2025-04-20","objectID":"/kprc/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC","uri":"/kprc/#"},{"categories":["BT"],"content":" 总结KRPC 是 BitTorrent DHT 的基石通信协议。它利用 UDP 的高效性和 Bencode 的简洁性，定义了一套清晰的查询/响应机制（ping, find_node, get_peers, announce_peer）以及错误处理方式。通过事务 ID (t) 匹配请求和响应，并使用紧凑的二进制格式 (nodes, values) 传输节点和 Peer 信息，KRPC 使得数百万 BitTorrent 客户端能够有效地组成一个庞大、去中心化的网络，用于发现彼此并协调文件共享。 ","date":"2025-04-20","objectID":"/kprc/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"KRPC","uri":"/kprc/#总结"},{"categories":["BT"],"content":" 1 算法流程1. 节点 ID (Node ID) 结构：通常是一个 160 位或 256 位的随机数。这个长度决定了网络的理论最大规模以及发生 ID 碰撞（两个节点生成相同 ID）的概率（极低）。 生成：节点第一次启动时，通常会随机生成自己的 Node ID。这个 ID 在节点的生命周期内保持不变。 意义：ID 不仅仅是标识符，它定义了节点在 Kademlia “地址空间”中的位置。 2. XOR 距离度量 (XOR Metric) 定义：两个 ID（无论是节点 ID 还是数据 Key）之间的距离是通过它们的**按位异或（XOR）**操作结果来定义的。 distance(ID1, ID2) = ID1 XOR ID2 这个结果被解释为一个无符号整数。数值越小，表示“距离”越近。 属性： distance(A, A) = 0 distance(A, B) \u003e 0 (如果 A ≠ B) distance(A, B) = distance(B, A) （对称性） distance(A, C) \u003c= distance(A, B) + distance(B, C) （三角不等式） 这些属性使得 XOR 距离成为一个真正的度量空间。 优点： 计算简单快速。 能够均匀地分布节点，没有“中心点”。 使得路由非常高效：每次跳转都能保证在“距离”上更接近目标。 3. K-桶 (k-buckets) 目的：每个节点维护一个路由表，用来存储它所知道的其他节点的信息（IP 地址、UDP 端口、Node ID）。K-桶是这个路由表的核心结构。 结构：路由表被划分为多个列表，称为 k-桶。每个 k-桶对应 ID 空间中的一个特定距离范围。 假设 ID 是 160 位的。可以有 160 个 k-桶。 第 i 个 k-桶（0 \u003c= i \u003c 160）存储与当前节点距离在 [2^i, 2^(i+1)) 范围内的节点信息。 这意味着： 桶 0 包含距离在 [1, 2) 之间的节点（只有一个可能，因为 XOR 距离为 1）。 桶 1 包含距离在 [2, 4) 之间的节点。 … 桶 159 包含距离在 [2^159, 2^160) 之间的节点。 桶的大小 (k)：每个 k-桶最多只能存储 k 个节点的信息。k 是一个系统参数，通常取 20。 目的：k 提供了冗余。即使桶中的某些节点下线，仍然有其他节点可以联系。k 的选择是在网络开销和系统鲁棒性之间做权衡。 更新机制 (重要)：当一个节点（我们称之为 A）收到来自另一个节点（B）的任何消息（请求或响应）时，它会尝试更新与 B 对应的 k-桶： 计算 A 和 B 之间的距离 d，确定 B 应该属于哪个 k-桶。 检查 B 是否已在桶中： 如果在：将被观察到的节点 B 移动到该 k-桶列表的末尾（表示它是最新联系过的/最活跃的）。 如果不在： 桶未满（少于 k 个条目）：将 B 的信息（ID, IP, Port）添加到 k-桶列表的末尾。 桶已满（已有 k 个条目）：找到桶中最久未联系的节点（通常是列表头部的节点），我们称之为 C。 节点 A 向 C 发送一个 PING RPC（见下文）。 如果 C 回复了 PONG：说明 C 仍然在线。A 将 C 移动到桶列表的末尾（标记为最新联系过），并丢弃新节点 B 的信息（因为桶满了，且旧节点依然活跃）。 如果 C 没有回复（超时）：说明 C 可能下线了。A 将 C 从 k-桶中移除，然后将新节点 B 的信息添加到列表末尾。 这种机制优先保留稳定、长期在线的节点，因为它们对网络的健康更重要。 4. 远程过程调用 (RPCs) Kademlia 节点之间通过 UDP 消息进行通信。主要有四种 RPC： PING: 用来探测一个节点是否仍然在线。被 PING 的节点如果在线，应回复 PONG。 STORE(key, value): 请求接收方存储一个 (key, value) 数据对。接收方收到后应将其存储起来。通常数据会有一个过期时间。 FIND_NODE(target_id): 请求接收方返回其 k-桶中离 target_id 逻辑距离最近的 k 个节点的信息 (ID, IP, Port)。 FIND_VALUE(key): 与 FIND_NODE 类似，但有一个额外的目的。 如果接收方存储了 key 对应的 value，则直接返回该 value。 如果接收方没有存储该 key，则其行为与 FIND_NODE(key) 完全一样，返回它所知道的离 key 最近的 k 个节点信息。 5. 查找过程 (Lookup) 这是 Kademlia 最核心的操作之一，用于定位节点或数据。 目标：找到网络中离目标 ID (可以是节点 ID 或数据 Key) 最近的 k 个节点。 过程： 初始化：查找发起者从自己的 k-桶中挑选出离目标 ID 最近的 α (alpha) 个节点。（α 是一个并发参数，通常取 3）。 并发查询：向这 α 个节点同时发送 FIND_NODE (或 FIND_VALUE) RPC 请求。 维护候选列表：发起者维护一个“短名单”，记录目前已知的、离目标 ID 最近的节点，按距离排序。 迭代： 当收到一个节点的回复时，将其提供的节点信息加入短名单。 从短名单中选出尚未查询过的、距离目标最近的 α 个节点，向它们发送查询请求。 确保任何时候最多只有 α 个查询请求在进行中（outstanding）。 如果一个节点查询超时或失败，则不再考虑它。 终止：当发起者已经查询过短名单中距离目标最近的 k 个节点，并且它们都已回复（或者超时），或者当 FIND_VALUE 查找直接找到了值时，查找过程结束。 结果：对于 FIND_NODE，结果是发起者所能找到的、离目标 ID 最近的 k 个节点。对于 FIND_VALUE，结果可能是数据值本身，或者是最接近数据 Key 的 k 个节点。 6. 数据存储与发布 存储：当一个节点想要存储 (Key, Value) 对时，它首先执行 FIND_NODE(Key) 查找，找到离 Key 最近的 k 个节点。然后，它向这 k 个节点发送 STORE(Key, Value) RPC。 过期与重新发布 (Republish)：存储在节点上的 (Key, Value) 对通常会有一个过期时间（例如 24 小时）。为了保证数据持久性，最初发布数据的节点必须定期（在数据过期前）重新执行查找和存储过程，向当前离 Key 最近的 k 个节点发送 STORE 命令。 缓存/复制 (Replication)：收到 STORE 请求的节点也会缓存数据。有时节点还会主动将自己存储的数据复制给新加入的、距离 Key 更近的邻居节点，以提高数据可用性。 7. 加入网络 (Bootstrap) 一个新节点需要知道至少一个已经在网络中的节点（引导节点 Bootstrap Node）的地址。 新节点生成自己的 Node ID。 向引导节点发送 FIND_NODE(自己的 ID) 请求。 通过引导节点的回复，以及后续迭代查找过程，新节点逐渐填充自己的 k-桶，了解网络结构。 同时，新节点通过与其他节点的交互，也让网络中的其他节点认识了自己，将自己加入到它们的 k-桶中。 总结关键参数： k (桶大小/复制因子)：决定了每个距离范围存储多少联系人以及数据存储的冗余度。典型值为 20。 α (并发因子)：控制查找过程中并行查询的数量。典型值为 3。 ID 长度 (如 160 位)。 数据过期时间 (如 24 小时) 和 republish 时间间隔。 ","date":"2025-04-18","objectID":"/kademlia-%E7%AE%97%E6%B3%95-2/:1:0","series":["P2P下载解析"],"tags":["BT"],"title":"Kademlia 算法（二）","uri":"/kademlia-%E7%AE%97%E6%B3%95-2/#算法流程"},{"categories":["BT"],"content":" 2 节点Key 与 数据Key在 Kademlia 中，节点 ID 和数据（更准确地说是数据的 键 Key）都使用相同长度的 ID（例如 160 位或 256 位），并且存在于同一个 ID 空间中，都使用 XOR 来计算距离。这是一个巧妙的设计，因为它允许使用同一套路由算法来查找节点和定位数据存储的位置。 尽管它们在格式和度量空间上 内容相同，但它们在性质、生成方式、网络角色和关联信息上有着本质的不同： 实体性质 (Nature of Entity): 节点 ID (Node ID): 代表网络中一个活跃的参与者。它是一个实际运行 Kademlia 协议的计算机或进程。它是一个“活”的实体，可以发送和接收消息。 数据键 (Data Key / ID): 代表一份被动的数据的标识符。它只是一个名字或标签，指向某个具体的数据值（Value）。它本身不是一个活跃的实体，不能主动通信。 生成方式 (Generation Method): 节点 ID: 通常是节点首次加入网络时随机生成的。目标是让节点 ID 在整个 ID 空间中尽可能均匀分布。 数据键: 通常是通过对数据内容本身进行哈希运算（例如 SHA-1）得到的。这意味着 Key 是由它所代表的数据唯一确定的（内容寻址）。如果你知道数据内容，你就能计算出它的 Key。有时 Key 也可以通过其他方式生成（比如基于公钥），但它总是与数据内容或其来源相关，而不是随机的。 网络角色 (Role in Network): 节点 ID: 定义了节点在 Kademlia ID 空间中的“位置”。它用于路由决策（判断远近、选择下一跳）、填充 K-桶以及标识通信的端点。节点是执行操作（如 FIND_NODE, STORE）的主体。 数据键: 定义了数据在 Kademlia ID 空间中应该被存储的“目标位置”。它是 FIND_NODE 或 FIND_VALUE 查询的目标。网络根据这个 Key 来决定哪些节点（即节点 ID 与该 Key 距离最近的 k 个节点）负责存储与之关联的 Value。Key 是被操作的对象，而不是操作的主体。 关联信息 (Associated Information): 节点 ID: 与一个具体的网络地址（IP 地址和端口号）以及该节点的本地状态（如 K-桶内容）相关联。 数据键: 与一个数据值 (Value) 相关联。这个 (Key, Value) 对才是最终被存储和检索的信息单元。 生命周期/稳定性 (Lifecycle/Stability): 节点 ID: 在节点参与网络的生命周期内通常是稳定不变的。节点可能会上线或下线，但只要它运行，ID 就保持不变。 数据键: Key 本身（如果由内容哈希生成）只要数据内容不变就是固定的。但是，(Key, Value) 对在网络中的存储状态是有生命周期的，需要定期重新发布 (Republish) 以防止过期被清除。Key 的“存在”意义在于是否有人想存储或查找它代表的数据。 总结可以这样理解： 节点 ID 回答了“谁在网络里？”以及“这个参与者在网络的哪个逻辑位置？” 数据 Key 回答了“我们要找/存的是什么信息？”以及“这个信息应该放在网络的哪个逻辑区域附近？” 将它们放在同一个 ID 空间是 Kademlia 的核心优势之一，因为它简化了设计：寻找一个节点和寻找应该存储某个数据的节点使用了完全相同的查找机制（Lookup Procedure）和距离计算方法。你只需将目标（无论是节点 ID 还是数据 Key）传入查找算法即可。 ","date":"2025-04-18","objectID":"/kademlia-%E7%AE%97%E6%B3%95-2/:2:0","series":["P2P下载解析"],"tags":["BT"],"title":"Kademlia 算法（二）","uri":"/kademlia-%E7%AE%97%E6%B3%95-2/#节点key-与-数据key"},{"categories":["BT"],"content":"Kademlia 是一种通过分布式哈希表（DHT）实现的协议算法，专为非集中式对等网络（P2P）而设计。它由 Petar Maymounkov 和 David Mazières 于 2002 年提出。Kademlia 协议包含了对应网络的结构，规定了节点之间通过查询进行信息交换的方式。很多著名的点对点（P2P）系统，比如 BitTorrent 的 DHT 网络、以太坊（Ethereum）等，都使用了 Kademlia 或其变种算法。 Kademlia 的主要特点和概念： 基于 XOR 度量： Kademlia 使用异或（XOR）运算来计算节点之间的距离。对于两个节点 ID x 和 y，它们之间的距离定义为 d(x,y)=x⊕y。XOR 度量具有一些重要的数学性质，例如三角不等式，这使得路由更加高效。XOR 结果被解释为一个整数，数值越小表示距离越近。选择异或是因为通过它计算的距离享有几何距离公式的一些特征，尤其体现在以下几点：节点和它本身之间的异或距离是0；异或距离是对称的：即从A到B的异或距离与从B到A的异或距离是等同的；异或距离符合三角不等式：三个顶点A B C，AC异或距离小于或等于AB异或距离和BC异或距离之和。由于以上的这些属性，在实际的节点距离的度量过程中计算量将大大降低。Kademlia搜索的每一次迭代将距目标至少更近1 bit。一个基本的具有2的n次方个节点的Kademlia网络在最坏的情况下只需花n步就可找到被搜索的节点或值。 节点和密钥的 ID 空间： 网络中的每个节点都被分配一个唯一的 160 位（或更高）的 ID。存储在 DHT 中的每个数据项（键值对）也有一个相应的 160 位密钥。节点 ID 和密钥都位于相同的地址空间中。 k-桶（k-buckets）： 每个节点维护一个称为 k-桶的路由表。每个 k-桶对应于节点 ID 空间中的一个距离范围。具体来说，对于节点 ID 的每一位（从 0 到 159），节点维护一个包含最多 k 个其他节点的 ID 和网络地址的 k-桶，这些节点的 ID 与本节点 ID 在该位上不同，而在前面的所有位上相同。k 是一个系统参数，通常设置为 20。k-桶的主要作用是存储与本节点距离在特定范围内的其他活跃节点的信息。 节点查找（Node Lookup）： 当一个节点需要查找具有特定 ID 的另一个节点时，它会首先查询其 k-桶中距离目标 ID 最近的 α 个节点（α 是一个小的并行查询参数，通常为 3）。被查询的节点会返回它们所知道的距离目标 ID 更近的节点。查询节点会继续向新收到的节点发送查询，直到找到目标节点或找到 k 个它所知道的距离最近的节点。 数据存储和检索（Data Storage and Retrieval）： 存储： 当一个节点想要存储一个键值对时，它会找到 k 个距离该键的 ID 最近的节点，并将该键值对存储在这些节点上。 检索： 要检索与某个键关联的值，节点会执行类似于节点查找的过程，找到 k 个距离该键最近的节点，并向它们请求该值。如果存储该值的节点之一在线，它将返回该值。为了提高可靠性，值通常会存储在多个距离最近的节点上。 节点加入（Node Join）： 当一个新节点加入网络时，它需要知道至少一个已在网络中的引导节点。新节点首先联系引导节点，并执行节点查找过程来查找它自己的节点 ID 附近的节点。在此过程中，新节点会填充自己的 k-桶，并且其他节点也会将新节点添加到它们的 k-桶中。 节点离开（Node Departure）： Kademlia 协议对节点的突然离开具有一定的鲁棒性。由于信息被冗余地存储在多个节点上，并且每个节点都维护了多个邻居的信息，即使某些节点离线，网络仍然可以继续运行。节点可以通过定期地 ping 其 k-桶中的其他节点来检测离线的节点，并用新发现的节点替换它们。 Kademlia 的优势： 去中心化： 没有中心服务器，网络依赖于所有参与节点的共同努力。 容错性： 网络对节点的加入和离开具有较强的适应性。 可扩展性： 理论上可以支持大量的节点。 高效的查找： 基于 XOR 度量的路由使得查找过程相对高效，平均查找时间复杂度为 O(logN)，其中 N 是网络中节点的数量。 Kademlia 的应用： Kademlia 算法被广泛应用于各种 P2P 应用中，例如： 文件共享网络： 如 eMule 和 BitTorrent 的某些实现。 分布式存储系统。 分布式域名系统（DNS）。 即时通讯系统。 ","date":"2025-04-18","objectID":"/kademlia-%E7%AE%97%E6%B3%95-1/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"Kademlia 算法（一）","uri":"/kademlia-%E7%AE%97%E6%B3%95-1/#"},{"categories":["BT"],"content":" 1 算法思想我们用一个简单的比喻来理解 Kademlia 算法。 想象一下，你要在一个非常非常大的图书馆里找一本书，但是这个图书馆没有中央索引卡片系统，也没有管理员总台。更麻烦的是，书架（或者说，存书的地方）也不是按字母顺序或者主题排列的，而是有点随机。 Kademlia 就像是给这个混乱的图书馆设计的一套找书和放书的规则，让每个图书管理员（我们称之为“节点”或“计算机”）都能高效地找到任何一本书（我们称之为“数据”），或者知道该把新书交给谁保管。 它是怎么做到的呢？ 每个管理员和每本书都有一个独特的“身份证号”（ID）： 每个参与网络的计算机（节点）都会得到一个随机但唯一的 ID 号码。 同样，你想存储的每一份数据（比如一个文件）也会根据其内容生成一个唯一的 ID 号码（通常叫做“键 Key”）。 这些 ID 通常是很长的一串数字（比如 160 位或 256 位）。 定义了一种特殊的“距离”： Kademlia 不关心计算机实际的地理位置远近，而是定义了一种基于 ID 号码的“逻辑距离”。 最常用的方法是使用“异或（XOR）”运算来计算两个 ID 之间的距离。你可以简单理解为：两个 ID 号码越相似，它们的“距离”就越“近”。 关键点：这种距离是对称的（A 到 B 的距离等于 B 到 A 的距离），并且有明确的远近关系。 每个管理员（节点）都维护一个“通讯录”（路由表）： 每个节点不会记录网络中所有其他节点的信息，那太多了。 它只记录一部分其他节点的联系方式（IP 地址、端口、ID）。 这个通讯录是精心组织的，按照逻辑距离来分类。它会把联系人分到不同的“桶（k-bucket）”里。 规则是：离自己“近”的节点，它会知道得更详细、更多；离自己“远”的节点，它可能只知道几个代表。就像你很清楚你家邻居是谁，但对于很远城市的人，你可能只认识一两个。 找书（查找数据/节点）的过程： 假设你的节点 A 想找 ID 为 X 的那本书（数据），或者想联系 ID 为 Y 的那个管理员（节点）。 节点 A 先查看自己的通讯录，找出通讯录里记录的、ID 与目标 X 或 Y “逻辑距离”最近的几个节点（比如 K 个）。 节点 A 就去问这几个“距离最近”的节点：“嘿，你知道 ID 为 X/Y 的信息吗？或者你知道谁比你更接近 X/Y 吗？” 被问到的节点也会查看它们自己的通讯录，然后回复给节点 A 一批它们认为更接近目标 ID 的节点列表。 节点 A 收到回复后，更新自己了解到的“更近”的节点名单，然后继续向这个新名单里最接近目标的节点发出询问。 这个过程不断重复，每一次询问都会让你（节点 A）得到离目标 ID 更近的节点信息，就像问路一样，一步步接近目的地。 最终，你要么直接找到了持有数据 X 的节点，要么找到了节点 Y 本身，要么找到了理论上最应该存储数据 X 的那些节点（即使数据暂时不在那里）。 放书（存储数据）的过程： 当一个节点想要存储一份数据（有自己的 Key ID）时，它会先执行上述的“查找”过程，找到网络中那些节点 ID 与这份数据的 Key ID “逻辑距离”最近的一批节点。 然后，它会把这份数据发送给这些“最近”的节点，请求它们帮忙存储。通常会存储多份副本以防某个节点下线。 总结一下： Kademlia 就是一套让分布式网络中的计算机们，通过给彼此和数据分配独特的 ID，利用一种特殊的“逻辑距离”概念，并维护一个“远疏近密”的通讯录，从而能够像接力问路一样，快速高效地找到网络中任何其他计算机或存储的数据，而不需要一个中央协调者。 ","date":"2025-04-18","objectID":"/kademlia-%E7%AE%97%E6%B3%95-1/:1:0","series":["P2P下载解析"],"tags":["BT"],"title":"Kademlia 算法（一）","uri":"/kademlia-%E7%AE%97%E6%B3%95-1/#算法思想"},{"categories":["BT"],"content":"本文介绍 BitTorrent 使用的 DHT（分布式哈希表）网络，它通常被称为 “Mainline DHT”。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#"},{"categories":["BT"],"content":" 0.1 背景与目的最初，BitTorrent 依赖于 Tracker 服务器 来协调 Peer（下载或上传同一个文件的用户）之间的连接。用户客户端连接到 Tracker，报告自己的信息和想要的 Torrent 文件，Tracker 则返回其他正在下载/上传该文件的 Peer 的列表。这种方式的问题在于 Tracker 是一个中心点： 单点故障：如果 Tracker 服务器宕机或关闭，依赖它的 Torrent 就很难找到新的 Peer。 可审查性/易受攻击：Tracker 容易被监控或攻击。 扩展性限制：大型 Tracker 需要处理大量连接。 为了解决这些问题，BitTorrent 社区开发并集成了一个基于 Kademlia 算法的 DHT 网络。其主要目的是： 去中心化 Peer 发现：即使没有 Tracker 服务器，或者 Tracker 失效，客户端也能通过 DHT 网络找到其他下载相同 Torrent 的 Peer。 降低对 Tracker 的依赖：使得 “Trackerless” Torrent 成为可能，提高了整个 BitTorrent 生态的健壮性。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:1","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#背景与目的"},{"categories":["BT"],"content":" 0.2 基于 Kademlia 的实现BitTorrent 的 Mainline DHT 在很大程度上遵循了 Kademlia 算法的核心原则： 节点 ID：每个运行 DHT 功能的 BitTorrent 客户端（即 Peer）都会生成一个 160 位的随机 Node ID，代表其在 DHT 网络中的身份和位置。 XOR 距离：节点间以及节点与数据之间的“距离”同样使用 XOR 度量来计算。 K-桶 (k-buckets)：每个客户端维护一个路由表，包含若干 K-桶，用于存储它所知道的其他 DHT 节点（Peer）的信息（Node ID, IP 地址, UDP 端口），组织方式与标准 Kademlia 相同（按 XOR 距离范围划分，优先保留稳定节点）。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:2","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#基于-kademlia-的实现"},{"categories":["BT"],"content":" 0.3 关键区别与 BitTorrent 特定应用与通用的 Kademlia 用于存储任意 (Key, Value) 不同，BitTorrent DHT 的核心应用是存储和查询 Peer 信息。 “Key” 是 Info-Hash：在 BitTorrent DHT 中，最重要的“Key”是 Torrent 文件的 Info-Hash。这是一个根据 Torrent 文件元数据（info 字典部分）计算出的 160 位哈希值，唯一标识了一个特定的 Torrent 内容。 “Value” 是 Peer 列表：DHT 网络存储的“Value”不是任意数据，而是与特定 Info-Hash 相关联的 Peer 联系信息列表（IP 地址和端口号）。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#关键区别与-bittorrent-特定应用"},{"categories":["BT"],"content":" 0.4 核心工作流程：查找和宣告 Peer 查找 Peer (get_peers RPC)： 当一个 BitTorrent 客户端想要加入某个 Torrent（知道了它的 Info-Hash）时，它会将这个 Info-Hash 作为目标 Key，在 DHT 网络中发起查找。 它执行类似 Kademlia 的迭代查找过程：向自己路由表中距离 Info-Hash 最近的节点发送 get_peers 请求。 收到 get_peers(info_hash) 请求的节点： 如果它存储了该 Info-Hash 对应的 Peer 列表，它会返回这个列表（一部分或全部）。 如果它没有存储该 Info-Hash 的 Peer 信息，它会像 Kademlia 的 find_node 一样，返回自己路由表中距离该 Info-Hash 最近的 k 个节点的信息。 发起查找的客户端不断向返回结果中更接近 Info-Hash 的节点发送 get_peers 请求，逐步缩小范围，直到找到拥有该 Torrent 的 Peer，或者已经查询了它所知道的最接近 Info-Hash 的 k 个节点。 重要：当节点回复 get_peers 时（无论是返回 Peer 列表还是节点列表），它还会附带一个临时的 token。这个 token 在稍后的宣告步骤中需要用到。 宣告自己 (announce_peer RPC)： 一旦客户端开始下载某个 Torrent，为了让其他 Peer 能找到自己，它需要向 DHT 网络“宣告”自己的存在。 它首先执行 get_peers 查找（如上所述），找到网络中距离该 Torrent 的 Info-Hash 最近的 k 个节点。 然后，它向这些节点发送 announce_peer 请求。这个请求包含： Torrent 的 Info-Hash。 客户端监听 BitTorrent 连接的端口号。 从之前该节点回复 get_peers 时收到的那个 token。 收到 announce_peer 请求的节点会验证 token (通常是基于该节点的 IP 地址和时间戳生成，有时效性)，验证通过后，它就会将发送方（宣告者）的 IP 地址和端口号存储起来，与对应的 Info-Hash 关联。这样，当其他 Peer 查询这个 Info-Hash 时，该节点就能提供宣告者的联系信息。 Token 的作用：防止任何人随意宣告任意 Peer 的信息，确保只有真正参与该 Torrent 下载（并执行过 get_peers 查询）的客户端才能成功宣告。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#核心工作流程查找和宣告-peer"},{"categories":["BT"],"content":" 0.5 其他 RPCs ping: 与 Kademlia 相同，用于检查节点是否在线。 find_node: 与 Kademlia 相同，用于查找距离目标 ID 最近的节点，主要用于维护路由表。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:5","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#其他-rpcs"},{"categories":["BT"],"content":" 0.6 引导 (Bootstrap) 新启动的 BitTorrent 客户端需要知道至少一个已经在 DHT 网络中的节点地址（通常是一些长期运行的、硬编码在客户端或从上次运行保存下来的 “bootstrap nodes”，如 router.bittorrent.com）。 通过向引导节点发送 find_node 请求（查找自己的 Node ID），客户端开始填充自己的路由表并融入 DHT 网络。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#引导-bootstrap"},{"categories":["BT"],"content":" 0.7 DHT总结BitTorrent 的 Mainline DHT 是 Kademlia 算法的一个非常成功和广泛的应用实例。它通过去中心化的方式解决了 Peer 发现的关键问题，使得 BitTorrent 协议更加健壮和有弹性，不再完全依赖中心化的 Tracker 服务器。现代几乎所有的 BitTorrent 客户端都支持并默认启用了 DHT 功能。其核心机制就是利用 Kademlia 的路由和查找能力，专门用于在 P2P 网络中映射 Torrent 的 Info-Hash 到下载该 Torrent 的 Peer 列表。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:7","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#dht总结"},{"categories":["BT"],"content":" 0.8 Node ID 和 info_hashDHT 通常只有一个核心的路由表（基于 Kademlia 的 K-桶系统），它的组织结构是基于节点 ID 的。 核心路由表 (K-桶): 每个 DHT 节点维护一个路由表，其结构是 Kademlia 的 K-桶 (k-buckets)。 这个 K-桶系统是根据其他节点的 Node ID 与当前节点自身的 Node ID 之间的 XOR 距离来组织的。 K-桶里存储的是它所知道的其他 DHT 节点的联系信息（Node ID, IP 地址, 端口号）。 这个路由表是用来进行所有查找操作的基础，无论是查找其他节点 (find_node) 还是查找存储特定信息（如 Peer 列表）的节点 (get_peers)。 查找过程如何使用这个路由表: 当执行 find_node(target_node_id) 时: 目标 Key 是一个节点 ID。节点使用 K-桶查找离 target_node_id XOR 距离最近的已知节点，并向它们查询，逐步迭代，最终找到离目标节点 ID 最近的一批节点。 当执行 get_peers(info_hash) 时: 目标 Key 是一个文件的 info_hash。虽然 info_hash 不是一个节点 ID，但它仍然是 Kademlia ID 空间中的一个点。节点同样使用基于 Node ID 的 K-桶路由表，查找其路由表中已知节点中，Node ID 与这个 info_hash 的 XOR 距离最近的那些节点。然后向这些节点发送 get_peers 请求，逐步迭代，最终找到在 XOR 距离上最接近该 info_hash 的一批节点。 Peer 列表的存储 (关键区别): 路由表 (K-桶) 的作用是指路，告诉你“要找离目标 X 最近的节点，你应该去问谁”。 Peer 列表 (由 announce_peer 产生) 并不是存储在路由表里的。它是应用层的数据。 那些其 Node ID 最接近特定 info_hash 的节点，除了维护自己的路由表外，还会额外维护一个数据存储区域（比如一个内存中的哈希表或字典）。这个区域用来存储 announce_peer 请求带来的信息，即：info_hash -\u003e [ (IP1, Port1, timestamp1), (IP2, Port2, timestamp2), ... ] 以及相关的 token。 所以，存储 Peer 列表是那些“负责”该 info_hash 的节点的额外职责，它们使用一个独立于路由表的机制来存储这些数据。而其他节点只负责通过路由表把 get_peers 或 announce_peer 请求导向这些负责的节点。 总结: 只有一个主要的路由表（K-桶系统），它基于 Node ID 和 XOR 距离来组织，用于所有类型的查找（包括基于 info_hash 的查找）。 info_hash 作为 get_peers 的查找目标 Key，指导查找过程使用路由表向正确的方向进行。 info_hash 到 Peer 列表的映射关系，是作为数据被存储在那些 Node ID 最接近该 info_hash 的节点上的独立存储区域中，而不是存储在路由表本身里。 可以理解为：路由表是地图和导航系统（基于节点地址），而 Peer 列表是特定地点（接近 info_hash 的节点）存放的公告板（上面写着参与者的联系方式）。导航系统（路由表）本身不记录公告板的内容，只负责把你带到正确的地点。 ","date":"2025-04-18","objectID":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/:0:8","series":["P2P下载解析"],"tags":["BT"],"title":"BitTorrent  的 DHT协议","uri":"/bittorrent-%E7%9A%84-dht%E5%8D%8F%E8%AE%AE/#node-id-和-info_hash"},{"categories":["BT"],"content":"定位了DHT爬虫的一个问题，在这梳理一下BT握手流程 BitTorrent 客户端（假设为 A）与另一个 Peer（假设为 B）从建立 TCP 连接开始，经过标准握手、扩展握手，最终到通过 ut_metadata 扩展获取种子元数据的完整流程 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:0","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#"},{"categories":["BT"],"content":" 0.1 前提: 客户端 A 知道 Peer B 的 IP 地址和监听端口 (IP_B, Port_B)。 客户端 A 知道它感兴趣的种子的 info_hash。 客户端 A 没有这个种子的元数据通过磁力连接向B请求这个种子的信息 我们假设 Peer B 拥有这个种子的元数据，并且支持 BEP-10 扩展协议和 ut_metadata 扩展。 环境是我本地的环境这里A的地址为192.168.30.125:59806, B的地址是192.168.30.230:63219 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:1","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#前提"},{"categories":["BT"],"content":" 0.2 流程步骤:整体的流程如图，除了最后一次挥手没等停止抓包了， 图中长度66的都是没有其他信息的， dMAC(6)+sMAC(6)+type(2)(ipv4 0x0800) = 14 IP 头 5 * 4 = 20 TCP 头 5 * 4 = 20 + 可选 12 字节（主要是默认开的时间戳10B） 共66B ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:2","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#流程步骤"},{"categories":["BT"],"content":" 0.3 阶段一：建立 TCP 连接 0.3.0.1 1. A 发起连接: 客户端 A 的操作系统向 Peer B 的 (IP_B, Port_B) 发送一个 TCP SYN 包。 0.3.0.2 2. B 响应连接: Peer B 的操作系统接收到 SYN 包，如果端口正在监听且允许连接，则发送一个 TCP SYN-ACK 包 回给 A。 0.3.0.3 3. A 确认连接: 客户端 A 的操作系统接收到 SYN-ACK 包，发送一个 TCP ACK 包 给 B。 结果: TCP 三次握手完成。A 和 B 之间建立了一条可靠的、面向连接的 TCP 通道。现在可以互相发送应用层数据了。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#阶段一建立-tcp-连接"},{"categories":["BT"],"content":" 0.3 阶段一：建立 TCP 连接 0.3.0.1 1. A 发起连接: 客户端 A 的操作系统向 Peer B 的 (IP_B, Port_B) 发送一个 TCP SYN 包。 0.3.0.2 2. B 响应连接: Peer B 的操作系统接收到 SYN 包，如果端口正在监听且允许连接，则发送一个 TCP SYN-ACK 包 回给 A。 0.3.0.3 3. A 确认连接: 客户端 A 的操作系统接收到 SYN-ACK 包，发送一个 TCP ACK 包 给 B。 结果: TCP 三次握手完成。A 和 B 之间建立了一条可靠的、面向连接的 TCP 通道。现在可以互相发送应用层数据了。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#1-a-发起连接"},{"categories":["BT"],"content":" 0.3 阶段一：建立 TCP 连接 0.3.0.1 1. A 发起连接: 客户端 A 的操作系统向 Peer B 的 (IP_B, Port_B) 发送一个 TCP SYN 包。 0.3.0.2 2. B 响应连接: Peer B 的操作系统接收到 SYN 包，如果端口正在监听且允许连接，则发送一个 TCP SYN-ACK 包 回给 A。 0.3.0.3 3. A 确认连接: 客户端 A 的操作系统接收到 SYN-ACK 包，发送一个 TCP ACK 包 给 B。 结果: TCP 三次握手完成。A 和 B 之间建立了一条可靠的、面向连接的 TCP 通道。现在可以互相发送应用层数据了。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#2-b-响应连接"},{"categories":["BT"],"content":" 0.3 阶段一：建立 TCP 连接 0.3.0.1 1. A 发起连接: 客户端 A 的操作系统向 Peer B 的 (IP_B, Port_B) 发送一个 TCP SYN 包。 0.3.0.2 2. B 响应连接: Peer B 的操作系统接收到 SYN 包，如果端口正在监听且允许连接，则发送一个 TCP SYN-ACK 包 回给 A。 0.3.0.3 3. A 确认连接: 客户端 A 的操作系统接收到 SYN-ACK 包，发送一个 TCP ACK 包 给 B。 结果: TCP 三次握手完成。A 和 B 之间建立了一条可靠的、面向连接的 TCP 通道。现在可以互相发送应用层数据了。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:3","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#3-a-确认连接"},{"categories":["BT"],"content":" 0.4 阶段二：BitTorrent 标准握手 (BEP-3) 0.4.0.4 4. A 发送握手信息（第106号）: TCP 连接建立后，客户端 A 立即 构造标准的 68 字节 BitTorrent 握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e\u003cinfo_hash\u003e\u003cpeer_id_A\u003e 其中 reserved 字节的第 5 字节的位 4 设置为 1，表示 A 支持 BEP-10 扩展协议如果双方都在这个位上设置为 1，它们就可以在标准握手之后立即交换扩展握手消息，从而协商使用如 ut_metadata (元数据交换), ut_pex (Peer Exchange) 等多种现代 BitTorrent 扩展功能。 字节 7 (索引为 7), 位 3 (第 3 位)。掩码 (Mask) 0x04 (十六进制) 或 00000100 (二进制) 设置此位置表明该 Peer 支持 BEP-4 DHT Protocol (DHT 协议)。表明客户端理解并能够参与 DHT 网络。如果设置了此位，意味着该 Peer 可能运行一个 DHT 节点，并且（根据 BEP-4）理论上可以在与 BitTorrent P2P 流量相同的端口上响应 DHT 查询，不过我们KRPC监听端口和tcp端口不一样所以没有设置，设置此位是加入 Mainline DHT 网络的前提。 A 将这 68 字节数据交给其 TCP 协议栈，发送 TCP 数据包 给 B。 0.4.0.5 5. B 接收并验证握手信息: Peer B 的 TCP 协议栈 接收 TCP 数据包，并将数据递交给 BitTorrent 应用层。 B 检查协议字符串是否为 “BitTorrent protocol”，检查 info_hash 是否是它关心的种子。假设匹配。 B 记录下 A 的 peer_id_A。 B 检查 A 发来的 reserved 字节，发现 A 支持 BEP-10。 0.4.0.6 6. B 发送握手信息（108）: Peer B 构造自己的 68 字节标准握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e\u003cinfo_hash\u003e\u003cpeer_id_B\u003e (B 也在 reserved 字节中表明自己支持 BEP-10)。 B 发送 TCP 数据包 给 A。 0.4.0.7 7. A 接收并验证握手信息（只读取68, 可见108大小为333）: 客户端 A 的 TCP 协议栈 接收 TCP 数据包。 A 验证协议字符串和 info_hash。 A 记录下 B 的 peer_id_B。 A 检查 B 发来的 reserved 字节，确认 B 也支持 BEP-10。 结果: 标准握手完成。双方确认了对方身份和意图（针对同一个 info_hash），并且都知晓对方支持扩展协议。 这里有点不一样的是，BT客户端的实现互不相同，有的会等A发送扩展握手后在回应，有的直接在握手包后面回复扩展握手了，这里注意一下，前面读取握手包只读取68字节，剩下的，扩展握手时候在处理，qbt就是这种。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#阶段二bittorrent-标准握手-bep-3"},{"categories":["BT"],"content":" 0.4 阶段二：BitTorrent 标准握手 (BEP-3) 0.4.0.4 4. A 发送握手信息（第106号）: TCP 连接建立后，客户端 A 立即 构造标准的 68 字节 BitTorrent 握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e 其中 reserved 字节的第 5 字节的位 4 设置为 1，表示 A 支持 BEP-10 扩展协议如果双方都在这个位上设置为 1，它们就可以在标准握手之后立即交换扩展握手消息，从而协商使用如 ut_metadata (元数据交换), ut_pex (Peer Exchange) 等多种现代 BitTorrent 扩展功能。 字节 7 (索引为 7), 位 3 (第 3 位)。掩码 (Mask) 0x04 (十六进制) 或 00000100 (二进制) 设置此位置表明该 Peer 支持 BEP-4 DHT Protocol (DHT 协议)。表明客户端理解并能够参与 DHT 网络。如果设置了此位，意味着该 Peer 可能运行一个 DHT 节点，并且（根据 BEP-4）理论上可以在与 BitTorrent P2P 流量相同的端口上响应 DHT 查询，不过我们KRPC监听端口和tcp端口不一样所以没有设置，设置此位是加入 Mainline DHT 网络的前提。 A 将这 68 字节数据交给其 TCP 协议栈，发送 TCP 数据包 给 B。 0.4.0.5 5. B 接收并验证握手信息: Peer B 的 TCP 协议栈 接收 TCP 数据包，并将数据递交给 BitTorrent 应用层。 B 检查协议字符串是否为 “BitTorrent protocol”，检查 info_hash 是否是它关心的种子。假设匹配。 B 记录下 A 的 peer_id_A。 B 检查 A 发来的 reserved 字节，发现 A 支持 BEP-10。 0.4.0.6 6. B 发送握手信息（108）: Peer B 构造自己的 68 字节标准握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e (B 也在 reserved 字节中表明自己支持 BEP-10)。 B 发送 TCP 数据包 给 A。 0.4.0.7 7. A 接收并验证握手信息（只读取68, 可见108大小为333）: 客户端 A 的 TCP 协议栈 接收 TCP 数据包。 A 验证协议字符串和 info_hash。 A 记录下 B 的 peer_id_B。 A 检查 B 发来的 reserved 字节，确认 B 也支持 BEP-10。 结果: 标准握手完成。双方确认了对方身份和意图（针对同一个 info_hash），并且都知晓对方支持扩展协议。 这里有点不一样的是，BT客户端的实现互不相同，有的会等A发送扩展握手后在回应，有的直接在握手包后面回复扩展握手了，这里注意一下，前面读取握手包只读取68字节，剩下的，扩展握手时候在处理，qbt就是这种。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#4-a-发送握手信息第106号"},{"categories":["BT"],"content":" 0.4 阶段二：BitTorrent 标准握手 (BEP-3) 0.4.0.4 4. A 发送握手信息（第106号）: TCP 连接建立后，客户端 A 立即 构造标准的 68 字节 BitTorrent 握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e 其中 reserved 字节的第 5 字节的位 4 设置为 1，表示 A 支持 BEP-10 扩展协议如果双方都在这个位上设置为 1，它们就可以在标准握手之后立即交换扩展握手消息，从而协商使用如 ut_metadata (元数据交换), ut_pex (Peer Exchange) 等多种现代 BitTorrent 扩展功能。 字节 7 (索引为 7), 位 3 (第 3 位)。掩码 (Mask) 0x04 (十六进制) 或 00000100 (二进制) 设置此位置表明该 Peer 支持 BEP-4 DHT Protocol (DHT 协议)。表明客户端理解并能够参与 DHT 网络。如果设置了此位，意味着该 Peer 可能运行一个 DHT 节点，并且（根据 BEP-4）理论上可以在与 BitTorrent P2P 流量相同的端口上响应 DHT 查询，不过我们KRPC监听端口和tcp端口不一样所以没有设置，设置此位是加入 Mainline DHT 网络的前提。 A 将这 68 字节数据交给其 TCP 协议栈，发送 TCP 数据包 给 B。 0.4.0.5 5. B 接收并验证握手信息: Peer B 的 TCP 协议栈 接收 TCP 数据包，并将数据递交给 BitTorrent 应用层。 B 检查协议字符串是否为 “BitTorrent protocol”，检查 info_hash 是否是它关心的种子。假设匹配。 B 记录下 A 的 peer_id_A。 B 检查 A 发来的 reserved 字节，发现 A 支持 BEP-10。 0.4.0.6 6. B 发送握手信息（108）: Peer B 构造自己的 68 字节标准握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e (B 也在 reserved 字节中表明自己支持 BEP-10)。 B 发送 TCP 数据包 给 A。 0.4.0.7 7. A 接收并验证握手信息（只读取68, 可见108大小为333）: 客户端 A 的 TCP 协议栈 接收 TCP 数据包。 A 验证协议字符串和 info_hash。 A 记录下 B 的 peer_id_B。 A 检查 B 发来的 reserved 字节，确认 B 也支持 BEP-10。 结果: 标准握手完成。双方确认了对方身份和意图（针对同一个 info_hash），并且都知晓对方支持扩展协议。 这里有点不一样的是，BT客户端的实现互不相同，有的会等A发送扩展握手后在回应，有的直接在握手包后面回复扩展握手了，这里注意一下，前面读取握手包只读取68字节，剩下的，扩展握手时候在处理，qbt就是这种。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#5-b-接收并验证握手信息"},{"categories":["BT"],"content":" 0.4 阶段二：BitTorrent 标准握手 (BEP-3) 0.4.0.4 4. A 发送握手信息（第106号）: TCP 连接建立后，客户端 A 立即 构造标准的 68 字节 BitTorrent 握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e 其中 reserved 字节的第 5 字节的位 4 设置为 1，表示 A 支持 BEP-10 扩展协议如果双方都在这个位上设置为 1，它们就可以在标准握手之后立即交换扩展握手消息，从而协商使用如 ut_metadata (元数据交换), ut_pex (Peer Exchange) 等多种现代 BitTorrent 扩展功能。 字节 7 (索引为 7), 位 3 (第 3 位)。掩码 (Mask) 0x04 (十六进制) 或 00000100 (二进制) 设置此位置表明该 Peer 支持 BEP-4 DHT Protocol (DHT 协议)。表明客户端理解并能够参与 DHT 网络。如果设置了此位，意味着该 Peer 可能运行一个 DHT 节点，并且（根据 BEP-4）理论上可以在与 BitTorrent P2P 流量相同的端口上响应 DHT 查询，不过我们KRPC监听端口和tcp端口不一样所以没有设置，设置此位是加入 Mainline DHT 网络的前提。 A 将这 68 字节数据交给其 TCP 协议栈，发送 TCP 数据包 给 B。 0.4.0.5 5. B 接收并验证握手信息: Peer B 的 TCP 协议栈 接收 TCP 数据包，并将数据递交给 BitTorrent 应用层。 B 检查协议字符串是否为 “BitTorrent protocol”，检查 info_hash 是否是它关心的种子。假设匹配。 B 记录下 A 的 peer_id_A。 B 检查 A 发来的 reserved 字节，发现 A 支持 BEP-10。 0.4.0.6 6. B 发送握手信息（108）: Peer B 构造自己的 68 字节标准握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e (B 也在 reserved 字节中表明自己支持 BEP-10)。 B 发送 TCP 数据包 给 A。 0.4.0.7 7. A 接收并验证握手信息（只读取68, 可见108大小为333）: 客户端 A 的 TCP 协议栈 接收 TCP 数据包。 A 验证协议字符串和 info_hash。 A 记录下 B 的 peer_id_B。 A 检查 B 发来的 reserved 字节，确认 B 也支持 BEP-10。 结果: 标准握手完成。双方确认了对方身份和意图（针对同一个 info_hash），并且都知晓对方支持扩展协议。 这里有点不一样的是，BT客户端的实现互不相同，有的会等A发送扩展握手后在回应，有的直接在握手包后面回复扩展握手了，这里注意一下，前面读取握手包只读取68字节，剩下的，扩展握手时候在处理，qbt就是这种。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#6-b-发送握手信息108"},{"categories":["BT"],"content":" 0.4 阶段二：BitTorrent 标准握手 (BEP-3) 0.4.0.4 4. A 发送握手信息（第106号）: TCP 连接建立后，客户端 A 立即 构造标准的 68 字节 BitTorrent 握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e 其中 reserved 字节的第 5 字节的位 4 设置为 1，表示 A 支持 BEP-10 扩展协议如果双方都在这个位上设置为 1，它们就可以在标准握手之后立即交换扩展握手消息，从而协商使用如 ut_metadata (元数据交换), ut_pex (Peer Exchange) 等多种现代 BitTorrent 扩展功能。 字节 7 (索引为 7), 位 3 (第 3 位)。掩码 (Mask) 0x04 (十六进制) 或 00000100 (二进制) 设置此位置表明该 Peer 支持 BEP-4 DHT Protocol (DHT 协议)。表明客户端理解并能够参与 DHT 网络。如果设置了此位，意味着该 Peer 可能运行一个 DHT 节点，并且（根据 BEP-4）理论上可以在与 BitTorrent P2P 流量相同的端口上响应 DHT 查询，不过我们KRPC监听端口和tcp端口不一样所以没有设置，设置此位是加入 Mainline DHT 网络的前提。 A 将这 68 字节数据交给其 TCP 协议栈，发送 TCP 数据包 给 B。 0.4.0.5 5. B 接收并验证握手信息: Peer B 的 TCP 协议栈 接收 TCP 数据包，并将数据递交给 BitTorrent 应用层。 B 检查协议字符串是否为 “BitTorrent protocol”，检查 info_hash 是否是它关心的种子。假设匹配。 B 记录下 A 的 peer_id_A。 B 检查 A 发来的 reserved 字节，发现 A 支持 BEP-10。 0.4.0.6 6. B 发送握手信息（108）: Peer B 构造自己的 68 字节标准握手消息： \u003c\"BitTorrent protocol\"\u003e\u003c8 reserved bytes\u003e (B 也在 reserved 字节中表明自己支持 BEP-10)。 B 发送 TCP 数据包 给 A。 0.4.0.7 7. A 接收并验证握手信息（只读取68, 可见108大小为333）: 客户端 A 的 TCP 协议栈 接收 TCP 数据包。 A 验证协议字符串和 info_hash。 A 记录下 B 的 peer_id_B。 A 检查 B 发来的 reserved 字节，确认 B 也支持 BEP-10。 结果: 标准握手完成。双方确认了对方身份和意图（针对同一个 info_hash），并且都知晓对方支持扩展协议。 这里有点不一样的是，BT客户端的实现互不相同，有的会等A发送扩展握手后在回应，有的直接在握手包后面回复扩展握手了，这里注意一下，前面读取握手包只读取68字节，剩下的，扩展握手时候在处理，qbt就是这种。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:4","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#7-a-接收并验证握手信息只读取68-可见108大小为333"},{"categories":["BT"],"content":" 0.5 阶段三：扩展协议握手 (BEP-10) - 条件性 因为 A 和 B 都支持 BEP-10，所以此阶段会进行。_ 0.5.0.8 8. A 发送扩展握手（110）: 扩展握手很简单，不过要注意ID, 双方后续通信需要使用对方握手时候使用的ut_metadata ID 而且不能取0 客户端 A 构造 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e\u003cBencoded 载荷\u003e 载荷是一个 Bencode 字典，至少包含 m 字典，例如 {\"m\": {\"ut_metadata\": 1}} (表示 A 希望 B 在发送 ut_metadata 消息给 A 时使用 ID 1)。可能还包含 v (版本), metadata_size (如果 A 碰巧有元数据的话，但在此场景下 A 没有，所以不含或为 0) 等。 A 发送 TCP 数据包 给 B。 0.5.0.9 9. B 接收并处理扩展握手: Peer B 接收 TCP 数据包。 B 解析载荷，记录下 A 要求使用的扩展 ID 映射 (例如，知道发送 ut_metadata 给 A 要用 ID 1)。记录 A 的版本等信息。 0.5.0.10 10. B 发送扩展握手: Peer B 构造自己的 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e\u003cBencoded 载荷\u003e 载荷包含 B 的 m 字典，例如 {\"m\": {\"ut_metadata\": 3}, \"metadata_size\": 9308} (表示 B 希望 A 在发送 ut_metadata 给 B 时使用 ID 3，并且 B 宣告它拥有的元数据大小为 12345 字节)。 B 发送 TCP 数据包 给 A。 A 接收并处理扩展握手(108后半部分）: 客户端 A 接收 TCP 数据包。 A 解析载荷，记录下 B 要求使用的扩展 ID 映射 (知道发送 ut_metadata 给 B 要用 ID 2)。 A 从 B 的握手消息中获知了元数据的确切大小 (metadata_size: 9308)。 扩展协议握手完成。双方知道了如何互相发送扩展消息（特别是 ut_metadata），并且 A 知道了元数据的总大小。 解释一下其余字段，ut_pex 是节点交换协议标识位，reqq是说明piece分片请求中，由于可以流水线处理，最大支持的处理数，v 可选是版本， your ip 是对方看到的IP ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:5","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#阶段三扩展协议握手-bep-10---条件性"},{"categories":["BT"],"content":" 0.5 阶段三：扩展协议握手 (BEP-10) - 条件性 因为 A 和 B 都支持 BEP-10，所以此阶段会进行。_ 0.5.0.8 8. A 发送扩展握手（110）: 扩展握手很简单，不过要注意ID, 双方后续通信需要使用对方握手时候使用的ut_metadata ID 而且不能取0 客户端 A 构造 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷是一个 Bencode 字典，至少包含 m 字典，例如 {\"m\": {\"ut_metadata\": 1}} (表示 A 希望 B 在发送 ut_metadata 消息给 A 时使用 ID 1)。可能还包含 v (版本), metadata_size (如果 A 碰巧有元数据的话，但在此场景下 A 没有，所以不含或为 0) 等。 A 发送 TCP 数据包 给 B。 0.5.0.9 9. B 接收并处理扩展握手: Peer B 接收 TCP 数据包。 B 解析载荷，记录下 A 要求使用的扩展 ID 映射 (例如，知道发送 ut_metadata 给 A 要用 ID 1)。记录 A 的版本等信息。 0.5.0.10 10. B 发送扩展握手: Peer B 构造自己的 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷包含 B 的 m 字典，例如 {\"m\": {\"ut_metadata\": 3}, \"metadata_size\": 9308} (表示 B 希望 A 在发送 ut_metadata 给 B 时使用 ID 3，并且 B 宣告它拥有的元数据大小为 12345 字节)。 B 发送 TCP 数据包 给 A。 A 接收并处理扩展握手(108后半部分）: 客户端 A 接收 TCP 数据包。 A 解析载荷，记录下 B 要求使用的扩展 ID 映射 (知道发送 ut_metadata 给 B 要用 ID 2)。 A 从 B 的握手消息中获知了元数据的确切大小 (metadata_size: 9308)。 扩展协议握手完成。双方知道了如何互相发送扩展消息（特别是 ut_metadata），并且 A 知道了元数据的总大小。 解释一下其余字段，ut_pex 是节点交换协议标识位，reqq是说明piece分片请求中，由于可以流水线处理，最大支持的处理数，v 可选是版本， your ip 是对方看到的IP ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:5","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#8-a-发送扩展握手110"},{"categories":["BT"],"content":" 0.5 阶段三：扩展协议握手 (BEP-10) - 条件性 因为 A 和 B 都支持 BEP-10，所以此阶段会进行。_ 0.5.0.8 8. A 发送扩展握手（110）: 扩展握手很简单，不过要注意ID, 双方后续通信需要使用对方握手时候使用的ut_metadata ID 而且不能取0 客户端 A 构造 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷是一个 Bencode 字典，至少包含 m 字典，例如 {\"m\": {\"ut_metadata\": 1}} (表示 A 希望 B 在发送 ut_metadata 消息给 A 时使用 ID 1)。可能还包含 v (版本), metadata_size (如果 A 碰巧有元数据的话，但在此场景下 A 没有，所以不含或为 0) 等。 A 发送 TCP 数据包 给 B。 0.5.0.9 9. B 接收并处理扩展握手: Peer B 接收 TCP 数据包。 B 解析载荷，记录下 A 要求使用的扩展 ID 映射 (例如，知道发送 ut_metadata 给 A 要用 ID 1)。记录 A 的版本等信息。 0.5.0.10 10. B 发送扩展握手: Peer B 构造自己的 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷包含 B 的 m 字典，例如 {\"m\": {\"ut_metadata\": 3}, \"metadata_size\": 9308} (表示 B 希望 A 在发送 ut_metadata 给 B 时使用 ID 3，并且 B 宣告它拥有的元数据大小为 12345 字节)。 B 发送 TCP 数据包 给 A。 A 接收并处理扩展握手(108后半部分）: 客户端 A 接收 TCP 数据包。 A 解析载荷，记录下 B 要求使用的扩展 ID 映射 (知道发送 ut_metadata 给 B 要用 ID 2)。 A 从 B 的握手消息中获知了元数据的确切大小 (metadata_size: 9308)。 扩展协议握手完成。双方知道了如何互相发送扩展消息（特别是 ut_metadata），并且 A 知道了元数据的总大小。 解释一下其余字段，ut_pex 是节点交换协议标识位，reqq是说明piece分片请求中，由于可以流水线处理，最大支持的处理数，v 可选是版本， your ip 是对方看到的IP ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:5","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#9-b-接收并处理扩展握手"},{"categories":["BT"],"content":" 0.5 阶段三：扩展协议握手 (BEP-10) - 条件性 因为 A 和 B 都支持 BEP-10，所以此阶段会进行。_ 0.5.0.8 8. A 发送扩展握手（110）: 扩展握手很简单，不过要注意ID, 双方后续通信需要使用对方握手时候使用的ut_metadata ID 而且不能取0 客户端 A 构造 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷是一个 Bencode 字典，至少包含 m 字典，例如 {\"m\": {\"ut_metadata\": 1}} (表示 A 希望 B 在发送 ut_metadata 消息给 A 时使用 ID 1)。可能还包含 v (版本), metadata_size (如果 A 碰巧有元数据的话，但在此场景下 A 没有，所以不含或为 0) 等。 A 发送 TCP 数据包 给 B。 0.5.0.9 9. B 接收并处理扩展握手: Peer B 接收 TCP 数据包。 B 解析载荷，记录下 A 要求使用的扩展 ID 映射 (例如，知道发送 ut_metadata 给 A 要用 ID 1)。记录 A 的版本等信息。 0.5.0.10 10. B 发送扩展握手: Peer B 构造自己的 BEP-10 扩展握手消息 (消息 ID 固定为 0)： \u003c长度前缀\u003e 载荷包含 B 的 m 字典，例如 {\"m\": {\"ut_metadata\": 3}, \"metadata_size\": 9308} (表示 B 希望 A 在发送 ut_metadata 给 B 时使用 ID 3，并且 B 宣告它拥有的元数据大小为 12345 字节)。 B 发送 TCP 数据包 给 A。 A 接收并处理扩展握手(108后半部分）: 客户端 A 接收 TCP 数据包。 A 解析载荷，记录下 B 要求使用的扩展 ID 映射 (知道发送 ut_metadata 给 B 要用 ID 2)。 A 从 B 的握手消息中获知了元数据的确切大小 (metadata_size: 9308)。 扩展协议握手完成。双方知道了如何互相发送扩展消息（特别是 ut_metadata），并且 A 知道了元数据的总大小。 解释一下其余字段，ut_pex 是节点交换协议标识位，reqq是说明piece分片请求中，由于可以流水线处理，最大支持的处理数，v 可选是版本， your ip 是对方看到的IP ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:5","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#10-b-发送扩展握手"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#阶段四元数据交换-"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#12-a-请求元数据块1002"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#13-b-接收请求并发送数据块"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#14-a-接收并存储数据块"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#15-a-请求并接收后续块-如果需要"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#16-a-完成接收并校验"},{"categories":["BT"],"content":" 0.6 阶段四：元数据交换 (ut_metadata, BEP-9) - 条件性 因为 A 需要元数据，且 B 支持 ut_metadata 并拥有元数据，所以此阶段会进行。A 知道需要向 B 发送 ID 为 3 的消息来请求元数据。_ 0.6.0.11 12. A 请求元数据块（1002）: 客户端 A 根据获知的 metadata_size (9308 字节) 和标准块大小 (16 KB = 16384 字节)，计算出需要请求多少个元数据块 (我们这个就1快儿)。假设元数据大小是 30000 字节，则需要请求块 0 和块 1。 A 开始请求第一个元数据块 (索引 0)： 构造 ut_metadata 请求载荷 (Bencode 字典): {\"msg_type\": 0, \"piece\": 0} 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencoded 载荷\u003e (注意消息 ID 是 3) A 发送 TCP 数据包 给 B。 (如果需要更多块，A 可以连续发送对块 1, 2… 的请求，不必等待响应，这称为流水线 Pipelining)。 0.6.0.12 13. B 接收请求并发送数据块: Peer B 接收 TCP 数据包。 B 解析消息，识别出是 ID 为 2 (对应 ut_metadata) 的消息，再解析内部载荷，看到是 msg_type: 0 (请求)，请求的是 piece: 0。 B 获取元数据的第 0 块数据（从字节 0 到 16383，但在此例中只有 9308 字节）。 B 构造 ut_metadata 数据载荷 (Bencode 字典 + 原始数据): {\"msg_type\": 1, \"piece\": 0, \"total_size\": 9308} 后紧跟 9308 字节的元数据块。 B 构造 BEP-10 消息: \u003c长度前缀\u003e\u003c上述 Bencode 载荷 + 原始数据块\u003e (注意消息 ID 是 1，这是 A 在握手中指定的 B-\u003eA 的 ut_metadata ID)。 B 发送 TCP 数据包 给 A。 如下图显然我们这里tcp分包了，然后在119重组 0.6.0.13 14. A 接收并存储数据块: 客户端 A 接收 TCP 数据包。 A 解析消息，识别出是 ID 为 1 (对应 ut_metadata)，解析内部载荷看到是 msg_type: 1 (数据)，对应 piece: 0，总大小 total_size: 9308。 A 读取随后的 9308 字节原始数据。 A 将这块数据存储在内存中，作为元数据的第 0 块。 0.6.0.14 15. A 请求并接收后续块 (如果需要): 如果元数据大于 16 KiB，A 会继续发送对后续块 (piece: 1, piece: 2…) 的请求，B 也会类似地响应数据块。A 持续接收并组装。 0.6.0.15 16. A 完成接收并校验: 当 A 接收完所有预期的块（根据 total_size 判断）后，它将所有块按顺序拼接起来，得到完整的 Bencode 编码的 info 字典数据。 A 计算这段完整数据的 SHA-1 哈希值。 A 将计算出的哈希与它最初从 Magnet 链接得到的 info_hash 进行比较。 结果: 匹配: A 成功获取并验证了元数据！现在它可以解析这个 info 字典，了解文件结构、大小、分块哈希等，并开始请求实际的文件数据块。 不匹配: 获取元数据失败，A 可能会丢弃数据并尝试从其他 Peer 获取。 大功告成了 0.6.0.16 17. 手动关闭了连接实际连接可能不会这么快关闭，毕竟还要传输数据 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:6","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#17-手动关闭了连接"},{"categories":["BT"],"content":" 0.7 其他实际下载中，会有些其他和拓展协议并列的消息，需要注意过滤掉，比如MsgTypeExt: 5的bitfield,用于表示B已经下载的分块。 还有就是，可见我们连续发送了多个分片元数据请求，这个请求后B开始发送元数据到A,注意超时时间不要设置的太短，如果网络情况差，可能不会很快。 ","date":"2025-04-18","objectID":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/:0:7","series":["P2P下载解析"],"tags":["BT"],"title":"BT握手与TCP的连接与释放","uri":"/bt%E6%8F%A1%E6%89%8B%E4%B8%8Etcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/#其他"},{"categories":["软件折腾","Obsidian"],"content":"官方自带的模板还是太弱了, 如果需要自动生成frontmatter，还是需要第三方插件 目前是利用这个插件，因为使用js生成内容，所以理论上什么都可以用模板来填 https://github.com/SilentVoid13/Templater 先贴一下配置 yaml --- title: \u003c% tp.file.folder() %\u003e date: \u003c% tp.file.creation_date(\"YYYY-MM-DDTHH:mm:ss.SSSZ\") %\u003e lastmod: \u003c% tp.file.last_modified_date(\"YYYY-MM-DDTHH:mm:ss.SSSZ\") %\u003e draft: true tags: series: description: \u003c%* const fullPath = tp.file.folder(true); // 获取路径，例如 \"content/posts/A/B/C\" const pathArray = fullPath.split(\"/\"); // 分割路径 const endIndex = pathArray.length-1 const categories = pathArray.slice(2, endIndex); // 提取第3和第4级目录（\"A\", \"B\"） tR += \"categories:\\n\"; if (categories.length === 0) { tR += \" - None\\n\"; // 如果没有足够的目录 } else { for (const category of categories) { if (category) { // 确保目录非空 tR += ` - ${category}\\n`; } } }%\u003e --- 在 Obsidian 中使用 Templater 插件获取文件的目录和上级目录，可以通过 tp.file 对象的相关方法实现。以下是具体方法和代码示例： ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#"},{"categories":["软件折腾","Obsidian"],"content":" 0.17 1. 获取当前文件所在目录使用 tp.file.folder() 方法可以获取当前文件所在的目录。 语法： javascript \u003c% tp.file.folder() %\u003e // 返回当前文件的目录名称（不含路径） \u003c% tp.file.folder(true) %\u003e // 返回当前文件的完整路径（相对于 Vault 根目录） 示例： 假设文件路径为 Projects/ClientA/ProjectX/Note.md： javascript \u003c% tp.file.folder() %\u003e // 输出：ProjectX \u003c% tp.file.folder(true) %\u003e // 输出：Projects/ClientA/ProjectX ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:1","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#1-获取当前文件所在目录"},{"categories":["软件折腾","Obsidian"],"content":" 0.18 2. 获取上级目录Templater 本身没有直接提供获取上级目录的内置方法，但可以通过处理 tp.file.folder(true) 返回的路径来提取上级目录。可以使用 JavaScript 字符串操作或正则表达式来实现。 方法：获取完整路径后，使用 split() 分割路径并提取上级目录。 示例代码： javascript \u003c%* const fullPath = tp.file.folder(true); // 获取完整路径，例如 \"Projects/ClientA/ProjectX\" const pathArray = fullPath.split(\"/\"); // 按斜杠分割路径 const parentFolder = pathArray.slice(0, -1).join(\"/\"); // 去掉最后一级，拼接为上级目录 tR += parentFolder; // 输出上级目录 %\u003e 输出： 如果 fullPath 是 Projects/ClientA/ProjectX，则 parentFolder 输出为 Projects/ClientA。 如果文件在根目录（fullPath 为空），则 parentFolder 输出为空字符串。 更简洁的写法（仅获取上级目录名称）： 如果只需要上级目录的名称（而不是完整路径），可以进一步处理： javascript \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); const parentFolderName = pathArray[pathArray.length - 2] || \"\"; // 获取倒数第二个元素 tR += parentFolderName; %\u003e 输出： 如果 fullPath 是 Projects/ClientA/ProjectX，则 parentFolderName 输出为 ClientA。 如果文件在根目录或只有一级目录，则输出空字符串。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:2","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#2-获取上级目录"},{"categories":["软件折腾","Obsidian"],"content":" 0.19 3. 结合使用示例假设你有一个 Templater 模板，想在文件中自动插入当前目录和上级目录的名称，可以这样写： javascript --- title: \u003c% tp.file.title %\u003e folder: \u003c% tp.file.folder() %\u003e parent_folder: \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); tR += pathArray[pathArray.length - 2] || \"None\"; %\u003e --- # \u003c% tp.file.title %\u003e 当前目录: \u003c% tp.file.folder() %\u003e 上级目录: \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); tR += pathArray[pathArray.length - 2] || \"None\"; %\u003e 输出示例（文件路径为 Projects/ClientA/ProjectX/Note.md）： yaml --- title: Note folder: ProjectX parent_folder: ClientA --- # Note 当前目录: ProjectX 上级目录: ClientA ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:3","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#3-结合使用示例"},{"categories":["软件折腾","Obsidian"],"content":" 0.20 4.时间日期如果你希望 date 和 lastmod 基于文件属性（例如创建时间或修改时间）动态生成，可以使用 tp.file.creation_date() 和 tp.file.last_modified_date()。以下是示例代码： text --- \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); const categories = pathArray.slice(2, 4); // 动态生成日期（ISO 8601 格式） const date = tp.file.creation_date(\"YYYY-MM-DDTHH:mm:ss.SSSZ\"); const lastmod = tp.file.last_modified_date(\"YYYY-MM-DDTHH:mm:ss.SSSZ\"); // 输出 YAML tR += `date: ${date}\\n`; tR += `lastmod: ${lastmod}\\n`; tR += \"categories:\\n\"; if (categories.length === 0) { tR += \" - None\\n\"; } else { for (const category of categories) { if (category) { tR += ` - ${category}\\n`; } } } %\u003e --- ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:4","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#4时间日期"},{"categories":["软件折腾","Obsidian"],"content":" 0.21 4. 注意事项 根目录情况：如果文件位于 Vault 的根目录，tp.file.folder(true) 返回空字符串，需在代码中处理这种情况（例如返回 “None” 或其他默认值）。 路径分隔符：Obsidian 使用 / 作为路径分隔符（即使在 Windows 上），因此无需担心平台差异。 调试：如果结果不符合预期，可以在模板中加入 console.log(fullPath)，然后在 Obsidian 的开发者工具（Ctrl+Shift+I）中查看控制台输出。 插件版本：确保 Templater 插件是最新版本，以避免潜在的路径处理问题。 性能：对于大量文件操作，建议测试模板性能，避免过于复杂的路径处理逻辑。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:5","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#4-注意事项"},{"categories":["软件折腾","Obsidian"],"content":" 0.22 5. 进阶：获取多级上级目录如果需要获取更高级的目录（例如上两级目录），可以调整 slice 或索引： javascript \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); const grandParentFolder = pathArray.slice(0, -2).join(\"/\") || \"None\"; // 上两级目录 tR += grandParentFolder; %\u003e 输出： 如果 fullPath 是 Projects/ClientA/ProjectX，则 grandParentFolder 输出为 Projects。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:6","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#5-进阶获取多级上级目录"},{"categories":["软件折腾","Obsidian"],"content":" 0.23 用更深的目录填充categories （更新）我们可以根据目录管理categories 要为 Obsidian 中位于 content/posts/A/B/C/exam.md 的文件使用 Templater 插件生成 YAML frontmatter 中的 categories 字段，只包含 A 和 B（忽略 content, posts, 和 C），需要从文件路径中提取特定层级的目录。以下是实现方法和代码。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:7","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#用更深的目录填充categories-更新"},{"categories":["软件折腾","Obsidian"],"content":" 0.24 实现步骤 获取文件路径：使用 tp.file.folder(true) 获取文件的相对路径（content/posts/A/B/C）。 提取所需目录：将路径按 / 分割，移除 content 和 posts，然后从剩余路径中提取 A 和 B，忽略 C。 生成 YAML 格式：将提取的目录（A 和 B）格式化为 YAML 列表 categories: [A, B]。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:8","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#实现步骤"},{"categories":["软件折腾","Obsidian"],"content":" 0.25 Templater 代码以下是生成所需 categories 字段的 Templater 模板代码： javascript --- \u003c%* const fullPath = tp.file.folder(true); // 获取路径，例如 \"content/posts/A/B/C\" const pathArray = fullPath.split(\"/\"); // 分割路径为 [\"content\", \"posts\", \"A\", \"B\", \"C\"] const categories = pathArray.slice(2, 4); // 提取 [\"A\", \"B\"]，跳过 \"content\" 和 \"posts\"，忽略 \"C\" tR += \"categories:\\n\"; if (categories.length === 0) { tR += \" - None\\n\"; // 如果没有符合条件的目录 } else { for (const category of categories) { tR += ` - ${category}\\n`; // 格式化为 YAML 列表 } } %\u003e --- ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:9","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#templater-代码"},{"categories":["软件折腾","Obsidian"],"content":" 0.26 输出结果对于文件 content/posts/A/B/C/exam.md，上述代码将生成以下 YAML frontmatter： yaml --- categories: - A - B --- ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:10","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#输出结果"},{"categories":["软件折腾","Obsidian"],"content":" 0.27 代码说明 tp.file.folder(true)：返回文件的完整相对路径（content/posts/A/B/C）。 pathArray.slice(2, 4)： slice(2, 4) 从索引 2 开始（跳过 content 和 posts），到索引 4 结束（包含 A 和 B，排除 C）。 结果是 [\"A\", \"B\"]。 空路径处理：如果 categories 为空（例如路径不包含 A 和 B），输出 None 作为默认值。 YAML 格式：通过 for 循环生成 - A 和 - B，确保正确的 YAML 缩进（两个空格）。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:11","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#代码说明"},{"categories":["软件折腾","Obsidian"],"content":" 0.28 处理不同路径深度的通用版本如果文件路径可能变化（例如 content/posts/A/B/exam.md 或 content/posts/A/B/C/D/exam.md），可以用以下代码确保只提取 A 和 B（路径中第 3 和第 4 级目录）： javascript --- \u003c%* const fullPath = tp.file.folder(true); // 获取路径，例如 \"content/posts/A/B/C\" const pathArray = fullPath.split(\"/\"); // 分割路径 const categories = pathArray.slice(2, 4); // 提取第3和第4级目录（\"A\", \"B\"） tR += \"categories:\\n\"; if (categories.length === 0) { tR += \" - None\\n\"; // 如果没有足够的目录 } else { for (const category of categories) { if (category) { // 确保目录非空 tR += ` - ${category}\\n`; } } } %\u003e --- 输出示例： 文件 content/posts/A/B/C/exam.md： yaml --- categories: - A - B --- 文件 content/posts/A/B/exam.md： yaml --- categories: - A - B --- 文件 content/posts/A/exam.md： yaml --- categories: - A --- 文件 content/posts/exam.md： yaml --- categories: - None --- ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:12","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#处理不同路径深度的通用版本"},{"categories":["软件折腾","Obsidian"],"content":" 0.29 注意事项 路径层级： 代码假定 content 和 posts 是固定的前两级目录，A 和 B 是第 3 和第 4 级。 如果路径结构不同（例如 content/A/B/exam.md），需要调整 slice(2, 4) 为 slice(1, 3)。 不足的目录：官方自带的模板还是太弱了 如果路径少于 4 级（例如 content/posts/A/exam.md），slice(2, 4) 只返回存在的目录（[\"A\"]）。 如果路径少于 3 级（例如 content/posts/exam.md），categories 为空，输出 None。 空目录处理：代码检查 category 是否为空，以避免输出空字符串。 调试：如果结果不符合预期，可以添加 \u003c% console.log(fullPath, pathArray, categories) %\u003e，在 Obsidian 开发者工具（Ctrl+Shift+I）中查看路径和数组内容。 YAML 格式：确保缩进为两个空格，符合 YAML 规范。 Templater 配置：确保 Templater 插件启用，且模板设置为自动触发（例如通过文件夹模板或手动插入）。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:13","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#注意事项"},{"categories":["软件折腾","Obsidian"],"content":" 0.30 扩展：添加其他元数据如果需要包含其他 frontmatter 字段（例如 title 或 date），可以扩展模板： javascript --- title: \u003c% tp.file.title %\u003e date: \u003c% tp.date.now(\"YYYY-MM-DD\") %\u003e \u003c%* const fullPath = tp.file.folder(true); const pathArray = fullPath.split(\"/\"); const categories = pathArray.slice(2, 4); tR += \"categories:\\n\"; if (categories.length === 0) { tR += \" - None\\n\"; } else { for (const category of categories) { if (category) { tR += ` - ${category}\\n`; } } } %\u003e --- 输出（文件 content/posts/A/B/C/exam.md）： yaml --- title: exam date: 2025-04-18 categories: - A - B --- ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:14","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#扩展添加其他元数据"},{"categories":["软件折腾","Obsidian"],"content":" 0.31 总结通过 tp.file.folder(true) 获取路径，使用 slice(2, 4) 提取 A 和 B，即可生成所需的 categories 字段。代码已考虑路径深度变化和边缘情况，适用于 content/posts/A/B/C/exam.md 及其变体。如果路径结构有其他特殊要求（例如动态跳过层级或包含其他目录），请提供更多细节，我可以进一步优化！ ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:15","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#总结"},{"categories":["软件折腾","Obsidian"],"content":" 0.32 参考资源 Templater 官方文档：tp.file 模块相关内容提供了路径操作的详细说明。 Obsidian 论坛讨论：关于获取上级目录的常见问题和解决方案。 ","date":"2025-04-18","objectID":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/:0:16","series":["利用obsidian从零开始搭建hugo博客"],"tags":null,"title":"obsidian 生成 Frontmatter","uri":"/obsidian-%E7%94%9F%E6%88%90-frontmatter/#参考资源"},{"categories":["Golang"],"content":" GO channel 详解本文是尽可能罗列channela知识点用来复习 ","date":"2025-03-23","objectID":"/chan/:0:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#go-channel-详解"},{"categories":["Golang"],"content":" 1 0.设计哲学 text \"Don't communicate by sharing memory; share memory by communicating.\" 不要通过共享内存来通信，而要通过通信来共享内存。 Channel是Go实现CSP（Communicating Sequential Processes）并发模型的核心机制。 ","date":"2025-03-23","objectID":"/chan/:1:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#0设计哲学"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#1-定义与使用"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#1基本语法"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#2-channel的三种状态"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#3发送操作-ch---value"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#4-接收操作--ch"},{"categories":["Golang"],"content":" 2 1. 定义与使用 2.0.1 1）基本语法 go // 声明channel var ch chan int // 声明一个传输int的channel ch = make(chan int) // 创建unbuffered channel ch = make(chan int, 10) // 创建buffered channel，容量为10 // 简化写法 ch := make(chan int) // unbuffered ch := make(chan int, 10) // buffered // 只读和只写的单向 channel var readOnly \u003c-chan int // 只能接收 var writeOnly chan\u003c- int // 只能发送 2.0.2 2) Channel的三种状态 go func channelStates() { var ch chan int // 1. nil channel fmt.Printf(\"nil channel: %v\\n\", ch == nil) // true // 2. open channel ch = make(chan int) fmt.Printf(\"open channel: %v\\n\", ch != nil) // true // 3. closed channel close(ch) // ch仍然不是nil，但已关闭 } 2.0.3 3)发送操作 (ch \u003c- value) go func sendExample() { ch := make(chan int, 2) // 非阻塞发送（有缓冲空间） ch \u003c- 1 ch \u003c- 2 // 这个发送会阻塞（缓冲区满） go func() { ch \u003c- 3 // 会阻塞直到有接收者 }() // 接收一个值，释放缓冲空间 \u003c-ch time.Sleep(time.Millisecond) // 让goroutine有机会接受 } 2.0.4 4) 接收操作 (\u003c-ch) go func receiveExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 方式1：基本接收 value := \u003c-ch fmt.Println(\"Received:\", value) // 1 // 方式2：检查channel是否关闭 value, ok := \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 2, true // 从已关闭的channel接收 value, ok = \u003c-ch fmt.Println(\"Received:\", value, \"OK:\", ok) // 0, false } 2.0.5 5) 关闭操作 (close(ch))关闭后接受是0值，发送 panic go func closeExample() { ch := make(chan int, 2) ch \u003c- 1 ch \u003c- 2 close(ch) // 仍然可以接收已发送的数据 fmt.Println(\u003c-ch) // 1 fmt.Println(\u003c-ch) // 2 // 从关闭的channel接收零值 fmt.Println(\u003c-ch) // 0 // 不能向已关闭的channel发送（会panic） // ch \u003c- 3 // panic: send on closed channel } ","date":"2025-03-23","objectID":"/chan/:2:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#5-关闭操作-closech"},{"categories":["Golang"],"content":" 3 2.Select语句","date":"2025-03-23","objectID":"/chan/:3:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#2select语句"},{"categories":["Golang"],"content":" 3.1 1. 基本用法 go func selectExample() { ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(time.Second) ch1 \u003c- \"from ch1\" }() go func() { time.Sleep(2 * time.Second) ch2 \u003c- \"from ch2\" }() // select会选择第一个就绪的case select { case msg1 := \u003c-ch1: fmt.Println(\"Received:\", msg1) case msg2 := \u003c-ch2: fmt.Println(\"Received:\", msg2) case \u003c-time.After(3 * time.Second): fmt.Println(\"Timeout\") } } ","date":"2025-03-23","objectID":"/chan/:3:1","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#1-基本用法"},{"categories":["Golang"],"content":" 3.2 2. 非阻塞操作对于channel，默认情况下，读/写 channel 都是阻塞模式，只有在 select 语句组成的多路复用分支中，与 channel 的交互会变成非阻塞模式 go func nonBlockingOperations() { ch := make(chan int, 1) // 非阻塞发送 select { case ch \u003c- 1: fmt.Println(\"Sent 1\") default: fmt.Println(\"Channel full\") } // 非阻塞接收 select { case value := \u003c-ch: fmt.Println(\"Received:\", value) default: fmt.Println(\"Channel empty\") } } ","date":"2025-03-23","objectID":"/chan/:3:2","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#2-非阻塞操作"},{"categories":["Golang"],"content":" 3.3 3. Select的随机性源码内存在伪随机函数确保随机选择 go func selectRandomness() { ch1 := make(chan int) ch2 := make(chan int) // 两个channel同时就绪时，select随机选择 go func() { ch1 \u003c- 1 }() go func() { ch2 \u003c- 2 }() time.Sleep(time.Millisecond) // 确保两个goroutine都就绪 select { case v := \u003c-ch1: fmt.Println(\"From ch1:\", v) case v := \u003c-ch2: fmt.Println(\"From ch2:\", v) } } ","date":"2025-03-23","objectID":"/chan/:3:3","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#3-select的随机性"},{"categories":["Golang"],"content":" 4 Channel的实现原理","date":"2025-03-23","objectID":"/chan/:4:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#channel的实现原理"},{"categories":["Golang"],"content":" 4.1 hchan结构体 go // runtime/chan.go type hchan struct { qcount uint // 当前channel队列中的元素数量 dataqsiz uint // 环形队列的大小(当前 channel 能存放的元素容量) buf unsafe.Pointer // 指向环形队列的指针 elemsize uint16 // channel 元素类型的大小 closed uint32 // 是否关闭 elemtype *_type // 元素类型 sendx uint // 发送索引(发送元素进入环形缓冲区的 index） recvx uint // 接收索引(接收元素所处的环形缓冲区的 index) recvq waitq // 接收等待队列(因接收而陷入阻塞的协程队列) sendq waitq // 发送等待队列(因发送而陷入阻塞的协程队列) lock mutex // 互斥锁 } // 等待队列 type waitq struct { first *sudog //队列头部 last *sudog //队列尾部 } // 等待的goroutine type sudog struct { g *g // 等待的goroutine next *sudog // 链表下一个 prev *sudog // 链表上一个 elem unsafe.Pointer // 数据元素? 读取/写入 channel 的数据的容器; TODO isSelect bool //标识当前协程是否处在 select 多路复用的流程中 c *hchan // channel } ","date":"2025-03-23","objectID":"/chan/:4:1","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#hchan结构体"},{"categories":["Golang"],"content":" 4.2 1. 发送流程 case1：写时存在阻塞读协程 • 加锁； • 从阻塞度协程队列中取出一个 goroutine 的封装对象 sudog； • 在 send 方法中，会基于 memmove 方法，直接将元素拷贝交给 sudog 对应的 goroutine； • 在 send 方法中会完成解锁动作. case2：写时无阻塞读协程但环形缓冲区仍有空间 • 加锁； • 将当前元素添加到环形缓冲区 sendx 对应的位置； • sendx++; • qcount++; • 解锁，返回. case3：写时无阻塞读协程且环形缓冲区无空间 • 加锁； • 构造封装当前 goroutine 的 sudog 对象； • 完成指针指向，建立 sudog、goroutine、channel 之间的指向关系； • 把 sudog 添加到当前 channel 的阻塞写协程队列中； • park 当前协程； • 倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被读协程取走）； • 解锁，返回 go // 简化的发送流程 func chansend(c *hchan, ep unsafe.Pointer, block bool) bool { // 1. 检查channel状态 if c == nil { if !block { return false } // 向nil channel发送会永久阻塞 gopark(...) } lock(\u0026c.lock) // 2. 检查是否已关闭 if c.closed != 0 { unlock(\u0026c.lock) panic(\"send on closed channel\") } // 3. 如果有等待的接收者，直接传递 if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep) unlock(\u0026c.lock) return true } // 4. 如果缓冲区有空间，存入缓冲区 if c.qcount \u003c c.dataqsiz { // 计算存储位置 qp := chanbuf(c, c.sendx) // 复制数据 typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026c.lock) return true } // 5. 缓冲区满，需要阻塞 if !block { unlock(\u0026c.lock) return false } // 6. 将当前goroutine加入发送等待队列 gp := getg() mysg := acquireSudog() mysg.g = gp mysg.elem = ep mysg.c = c c.sendq.enqueue(mysg) unlock(\u0026c.lock) // 7. 阻塞等待 gopark(...) return true } ","date":"2025-03-23","objectID":"/chan/:4:2","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#1-发送流程"},{"categories":["Golang"],"content":" 4.3 2. 接收流程 读nil会park挂起，直接死锁 channel关闭，读取直接解锁返回0值 如果有写的协程在等待， 加锁； 从阻塞写协程队列中获取到一个写协程； 倘若 channel 无缓冲区，则直接读取写协程元素，并唤醒写协程； 倘若 channel 有缓冲区，则读取缓冲区头部元素，并将写协程元素写入缓冲区尾部后唤醒写写成； 解锁，返回. 读时无阻塞写协程且缓冲区有元素 加锁； 获取到 recvx 对应位置的元素； recvx++ qcount– 解锁，返回 读时 无阻塞写协程且缓冲区无元素 即无数据可接收，需要阻塞 加锁； 构造 封装 当前goroutine的 sudog 对象； 完成指针指向，建立 sudog、goroutine、channel 之间的指向关系； 把 sudog 添加到当前 channel 的阻塞读协程队列中； park 当前协程； 倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被写入）； 解锁，返回 go // 简化的接收流程 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 1. 检查nil channel if c == nil { if !block { return false, false } // 从nil channel接收会永久阻塞 gopark(...) } lock(\u0026c.lock) // 2. 检查已关闭且无数据的情况 if c.closed != 0 \u0026\u0026 c.qcount == 0 { unlock(\u0026c.lock) if ep != nil { // 设置零值 typedmemclr(c.elemtype, ep) } return true, false } // 3. 如果有等待的发送者，直接接收 if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep) unlock(\u0026c.lock) return true, true } // 4. 如果缓冲区有数据，从缓冲区接收 if c.qcount \u003e 0 { qp := chanbuf(c, c.recvx) if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } // 5. 无数据可接收，需要阻塞 if !block { unlock(\u0026c.lock) return false, false } // 6. 将当前goroutine加入接收等待队列 gp := getg() mysg := acquireSudog() mysg.g = gp mysg.elem = ep mysg.c = c c.recvq.enqueue(mysg) unlock(\u0026c.lock) // 7. 阻塞等待 gopark(...) return true, true } ","date":"2025-03-23","objectID":"/chan/:4:3","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#2-接收流程"},{"categories":["Golang"],"content":" 5 常见陷阱和最佳实践","date":"2025-03-23","objectID":"/chan/:5:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#常见陷阱和最佳实践"},{"categories":["Golang"],"content":" 5.1 1. Goroutine泄露 go // ❌ 错误：可能导致goroutine泄露 func badPattern() { ch := make(chan int) go func() { // 如果没有接收者，这个goroutine会永久阻塞 ch \u003c- 1 }() // 如果这里提前返回，goroutine就泄露了 return } // ✅ 正确：使用context或close channel来避免泄露 func goodPattern(ctx context.Context) { ch := make(chan int) go func() { select { case ch \u003c- 1: // 发送成功 case \u003c-ctx.Done(): // 被取消，退出goroutine return } }() select { case result := \u003c-ch: fmt.Println(\"Received:\", result) case \u003c-ctx.Done(): return } } ","date":"2025-03-23","objectID":"/chan/:5:1","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#1-goroutine泄露"},{"categories":["Golang"],"content":" 5.2 2. Channel方向 go // ✅ 使用单向channel提高类型安全 func producer() \u003c-chan int { ch := make(chan int) go func() { defer close(ch) for i := 0; i \u003c 10; i++ { ch \u003c- i } }() return ch } func consumer(ch \u003c-chan int) { for value := range ch { fmt.Println(\"Consumed:\", value) } } ","date":"2025-03-23","objectID":"/chan/:5:2","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#2-channel方向"},{"categories":["Golang"],"content":" 5.3 3. 正确关闭Channel go // ✅ 发送者负责关闭channel func correctClose() { ch := make(chan int, 10) // 发送者 go func() { defer close(ch) // 发送完毕后关闭 for i := 0; i \u003c 5; i++ { ch \u003c- i } }() // 接收者 for value := range ch { // range会在channel关闭时退出 fmt.Println(value) } } ","date":"2025-03-23","objectID":"/chan/:5:3","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#3-正确关闭channel"},{"categories":["Golang"],"content":" 5.4 4. 写异常• 对于未初始化的 chan，写入操作会引发死锁； • 对于已关闭的 chan，写入操作会引发 panic. ","date":"2025-03-23","objectID":"/chan/:5:4","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#4--写异常"},{"categories":["Golang"],"content":" 6 总结Channel是Go并发编程的核心： 设计哲学：通过通信来共享内存 内部结构：基于环形缓冲区和等待队列 操作语义：发送、接收、关闭的详细行为 使用模式：生产者-消费者、Fan-out/in、工作池、管道 性能考虑：缓冲大小、内存使用、延迟vs吞吐量 最佳实践：避免泄露、正确关闭、类型安全 掌握Channel是写出高质量Go并发程序的关键。 ","date":"2025-03-23","objectID":"/chan/:6:0","series":null,"tags":null,"title":"channel 解读","uri":"/chan/#总结"},{"categories":["玩机","Linux"],"content":" 3 常用操作","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#常用操作"},{"categories":["玩机","Linux"],"content":" 3.1 tmux会话操作 创建会话 tmux new -t \u003csession_name\u003e 退出会话 Ctrl + B然后按下D 回到会话tmux attach ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:1","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux会话操作"},{"categories":["玩机","Linux"],"content":" 3.2 tmux窗口操作 创建窗口 Ctrl + B 然后按下C 窗口列表 Ctrl + B, W 切换下一个窗口 Ctrl + B, 然后按下N 切换上一个窗口 Ctrl + B, 然后按下P ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:2","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux窗口操作"},{"categories":["玩机","Linux"],"content":" 3.3 tmux 面板操作 垂直分割 Ctrl + B, % 水平分割 Ctrl + B, \" 切换布局 Ctrl + B, \u003cspace\u003e 调整窗口大小 Ctrl + B 按住不松手同时按下 \u003c上|下|左|右\u003e 关掉面板 Ctrl + B, X 当前面板全屏 Ctrl + B, Z, 再次使用Ctrl + B, Z 则退出全屏模式 ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:3","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux-面板操作"},{"categories":["玩机","Linux"],"content":" 3.4 tmux滚动 Ctrl + B, [","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:4","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux滚动-ctrl--b-"},{"categories":["玩机","Linux"],"content":" 4 配置文件","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#配置文件"},{"categories":["玩机","Linux"],"content":" 4.1 tmux复制粘贴如果要复制粘贴，则把要复制的那个窗口调整成全屏模式Ctrl + B + Z 然后复制，接着退出全屏模式即可。后面的可以不用看了，改配置是最麻烦且容易出错的。 tmux默认的复制粘贴有点反人类，用鼠标直接复制的格式是错误的。添加下面的配置到~/.tmux.conf开启vi复制模式。 https://unix.stackexchange.com/questions/318281/how-to-copy-and-paste-with-a-mouse-with-tmux text # Linux only set -g mouse on bind -n WheelUpPane if-shell -F -t = \"#{mouse_any_flag}\" \"send-keys -M\" \"if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'\" bind -n WheelDownPane select-pane -t= \\; send-keys -M bind -n C-WheelUpPane select-pane -t= \\; copy-mode -e \\; send-keys -M bind -T copy-mode-vi C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-vi C-WheelDownPane send-keys -X halfpage-down bind -T copy-mode-emacs C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-emacs C-WheelDownPane send-keys -X halfpage-down # To copy, left click and drag to highlight text in yellow, # once you release left click yellow text will disappear and will automatically be available in clibboard # # Use vim keybindings in copy mode setw -g mode-keys vi # Update default binding of `Enter` to also use copy-pipe unbind -T copy-mode-vi Enter bind-key -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel \"xclip -selection c\" bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel \"xclip -in -selection clipboard\" 使得配置生效 text tmux source-file ~/.tmux.conf 然后回到session，按下shift，左键选择文本复制即可。 4.1.1 方法二：复制插件 tmux-yank首先安装插件管理 tpm text git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 使得插件管理生效，添加以下代码到~/.tmux.conf text # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 使得tpm生效 text tmux source ~/.tmux.conf 接下来安装tmux-yank，网~/.tmux.conf中间添加 text set -g @plugin 'tmux-plugins/tmux-yank' 打开tmux，输入Ctrl + B 然后按下I，开始安装插件。 4.1.2 怎么复制？添加两行 text setw -g mode-keys vi set -g mouse on 按下Ctr + B 再按下 ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux复制粘贴"},{"categories":["玩机","Linux"],"content":" 4.1 tmux复制粘贴如果要复制粘贴，则把要复制的那个窗口调整成全屏模式Ctrl + B + Z 然后复制，接着退出全屏模式即可。后面的可以不用看了，改配置是最麻烦且容易出错的。 tmux默认的复制粘贴有点反人类，用鼠标直接复制的格式是错误的。添加下面的配置到~/.tmux.conf开启vi复制模式。 https://unix.stackexchange.com/questions/318281/how-to-copy-and-paste-with-a-mouse-with-tmux text # Linux only set -g mouse on bind -n WheelUpPane if-shell -F -t = \"#{mouse_any_flag}\" \"send-keys -M\" \"if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'\" bind -n WheelDownPane select-pane -t= \\; send-keys -M bind -n C-WheelUpPane select-pane -t= \\; copy-mode -e \\; send-keys -M bind -T copy-mode-vi C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-vi C-WheelDownPane send-keys -X halfpage-down bind -T copy-mode-emacs C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-emacs C-WheelDownPane send-keys -X halfpage-down # To copy, left click and drag to highlight text in yellow, # once you release left click yellow text will disappear and will automatically be available in clibboard # # Use vim keybindings in copy mode setw -g mode-keys vi # Update default binding of `Enter` to also use copy-pipe unbind -T copy-mode-vi Enter bind-key -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel \"xclip -selection c\" bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel \"xclip -in -selection clipboard\" 使得配置生效 text tmux source-file ~/.tmux.conf 然后回到session，按下shift，左键选择文本复制即可。 4.1.1 方法二：复制插件 tmux-yank首先安装插件管理 tpm text git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 使得插件管理生效，添加以下代码到~/.tmux.conf text # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 使得tpm生效 text tmux source ~/.tmux.conf 接下来安装tmux-yank，网~/.tmux.conf中间添加 text set -g @plugin 'tmux-plugins/tmux-yank' 打开tmux，输入Ctrl + B 然后按下I，开始安装插件。 4.1.2 怎么复制？添加两行 text setw -g mode-keys vi set -g mouse on 按下Ctr + B 再按下 ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#方法二复制插件tmux-yank"},{"categories":["玩机","Linux"],"content":" 4.1 tmux复制粘贴如果要复制粘贴，则把要复制的那个窗口调整成全屏模式Ctrl + B + Z 然后复制，接着退出全屏模式即可。后面的可以不用看了，改配置是最麻烦且容易出错的。 tmux默认的复制粘贴有点反人类，用鼠标直接复制的格式是错误的。添加下面的配置到~/.tmux.conf开启vi复制模式。 https://unix.stackexchange.com/questions/318281/how-to-copy-and-paste-with-a-mouse-with-tmux text # Linux only set -g mouse on bind -n WheelUpPane if-shell -F -t = \"#{mouse_any_flag}\" \"send-keys -M\" \"if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'\" bind -n WheelDownPane select-pane -t= \\; send-keys -M bind -n C-WheelUpPane select-pane -t= \\; copy-mode -e \\; send-keys -M bind -T copy-mode-vi C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-vi C-WheelDownPane send-keys -X halfpage-down bind -T copy-mode-emacs C-WheelUpPane send-keys -X halfpage-up bind -T copy-mode-emacs C-WheelDownPane send-keys -X halfpage-down # To copy, left click and drag to highlight text in yellow, # once you release left click yellow text will disappear and will automatically be available in clibboard # # Use vim keybindings in copy mode setw -g mode-keys vi # Update default binding of `Enter` to also use copy-pipe unbind -T copy-mode-vi Enter bind-key -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel \"xclip -selection c\" bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel \"xclip -in -selection clipboard\" 使得配置生效 text tmux source-file ~/.tmux.conf 然后回到session，按下shift，左键选择文本复制即可。 4.1.1 方法二：复制插件 tmux-yank首先安装插件管理 tpm text git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 使得插件管理生效，添加以下代码到~/.tmux.conf text # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 使得tpm生效 text tmux source ~/.tmux.conf 接下来安装tmux-yank，网~/.tmux.conf中间添加 text set -g @plugin 'tmux-plugins/tmux-yank' 打开tmux，输入Ctrl + B 然后按下I，开始安装插件。 4.1.2 怎么复制？添加两行 text setw -g mode-keys vi set -g mouse on 按下Ctr + B 再按下 ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:1","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#怎么复制"},{"categories":["玩机","Linux"],"content":" 4.2 tmux 设置开启用鼠标设置窗口大小 text set -g mouse on ","date":"2024-02-04","objectID":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:2","series":null,"tags":["tmux"],"title":"tmux小技巧","uri":"/tmux%E5%B0%8F%E6%8A%80%E5%B7%A7/#tmux-设置开启用鼠标设置窗口大小"},{"categories":["玩机","Linux"],"content":" 7 创建新用户useradd帮助 shell [root@localhost learn_redis]# useradd Usage: useradd [options] LOGIN useradd -D useradd -D [options] Options: -b, --base-dir BASE_DIR base directory for the home directory of the new account -c, --comment COMMENT GECOS field of the new account -d, --home-dir HOME_DIR home directory of the new account -D, --defaults print or change default useradd configuration -e, --expiredate EXPIRE_DATE expiration date of the new account -f, --inactive INACTIVE password inactivity period of the new account -g, --gid GROUP name or ID of the primary group of the new account -G, --groups GROUPS list of supplementary groups of the new account -h, --help display this help message and exit -k, --skel SKEL_DIR use this alternative skeleton directory -K, --key KEY=VALUE override /etc/login.defs defaults -l, --no-log-init do not add the user to the lastlog and faillog databases -m, --create-home create the user's home directory -M, --no-create-home do not create the user's home directory -N, --no-user-group do not create a group with the same name as the user -o, --non-unique allow to create users with duplicate (non-unique) UID -p, --password PASSWORD encrypted password of the new account -r, --system create a system account -R, --root CHROOT_DIR directory to chroot into -P, --prefix PREFIX_DIR prefix directory where are located the /etc/* files -s, --shell SHELL login shell of the new account -u, --uid UID user ID of the new account -U, --user-group create a group with the same name as the user -Z, --selinux-user SEUSER use a specific SEUSER for the SELinux user mapping root模式下： text useradd tignioj 设置密码 text passwd tignioj 创建用户的home目录 text mkdir /home/tignioj 授予目录权限给新用户 text chown -R tignioj:tignioj /home/tignioj 设定默认shell为bash text su tignioj chsh -s /bin/bash 以上命令可以用一行代替：useradd -m tignioj -s /bin/bash -p \"my_password\" shell [root@localhost:~]# useradd -m tignioj -s /bin/bash -p \"my_password\" [root@localhost:~]# ls -la /home/tignioj/ total 12 drwx------. 2 tignioj tignioj 62 Dec 12 22:46 . drwxr-xr-x. 4 root root 34 Dec 12 22:46 .. -rw-r--r--. 1 tignioj tignioj 18 Nov 24 2021 .bash_logout -rw-r--r--. 1 tignioj tignioj 193 Nov 24 2021 .bash_profile -rw-r--r--. 1 tignioj tignioj 231 Nov 24 2021 .bashrc [root@localhost:~]# ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:1:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#创建新用户"},{"categories":["玩机","Linux"],"content":" 8 授予用户sudo权限 text visudo 假如你输入visudo进入了nano编辑器，可以通过Ctrl + X退出编辑器。 由于个人习惯vim， 修改编辑器为vim。 text root@localhost:~# update-alternatives --config editor There are 4 choices for the alternative editor (providing /usr/bin/editor). Selection Path Priority Status ------------------------------------------------------------ 0 /bin/nano 40 auto mode 1 /bin/ed -100 manual mode 2 /bin/nano 40 manual mode * 3 /usr/bin/vim.basic 30 manual mode 4 /usr/bin/vim.tiny 15 manual mode Press \u003center\u003e to keep the current choice[*], or type selection number: 3 root@localhost:~# 添加tignioj的sudo权限 text # User privilege specification root ALL=(ALL:ALL) ALL tignioj ALL=(ALL:ALL) ALL ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:2:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#授予用户sudo权限"},{"categories":["玩机","Linux"],"content":" 9 允许公钥登录并禁密码和远程root登录禁止密码登录和远程登录 text vim /etc/ssh/sshd_config 找到PermitRootLogin和PasswordAuthentication，设置为no text PermitRootLogin no PasswordAuthentication no 还需要设置PubkeyAuthentication 为yes，否则登录会报错 Permission Denied (Public key) text PubkeyAuthentication yes RSAAuthentication yes ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:3:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#允许公钥登录并禁密码和远程root登录"},{"categories":["玩机","Linux"],"content":" 10 配置新用户登录公钥客户端，先生成公钥文件 text ➜ ~ ✗ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\lili/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\lili/.ssh/id_rsa. Your public key has been saved in C:\\Users\\lili/.ssh/id_rsa.pub. The key fingerprint is: SHA256:OYxuMybC8nztn9ShSyhew9ybczOeB9fEH6wudvlAM3Y lili@DESKTOP-9IJNN32 The key's randomart image is: +---[RSA 3072]----+ | | | | | .. | | o . oo | | . S . B.E.| | . + o +..+.= .| |. o o.% = .o... | | + o.*.*.=++.+. | | o.....*+++o .. | +----[SHA256]---- 先切换到新用户，在home目录下创建.ssh文件夹 text su tignioj mkdir .ssh cd .ssh 设置.ssh文件的权限700 text chmod 700 .ssh 创建authorized_keys文件，输入公钥。公钥是你登录的客户端.ssh目录下的id_rsa.pub里面的文件内容。 text vim authorized_keys 设置authorized_keys文件的权限为0600 text chmod 0600 authorized_keys 查看 text tignioj@localhost:~/.ssh$ ls -la total 20 drwxrwxr-x 2 tignioj tignioj 4096 Dec 13 11:37 . drwxr-xr-x 5 tignioj tignioj 4096 Dec 13 11:38 .. -rw------- 1 tignioj tignioj 742 Dec 13 11:37 authorized_keys -rw------- 1 tignioj tignioj 2622 Dec 13 11:37 id_rsa -rw-r--r-- 1 tignioj tignioj 585 Dec 13 11:37 id_rsa.pub tignioj@localhost:~/.ssh$ 重启sshd text systemctl restart sshd ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:4:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#配置新用户登录公钥"},{"categories":["玩机","Linux"],"content":" 11 远程登录windows terminal登录 text ssh tignioj@ip:port xshel7登录 注意要导入客户端（非linux服务器）的.ssh/id_rsa 文件 ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:5:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#远程登录"},{"categories":["玩机","Linux"],"content":" 12 错误排查客户端登录时显示： text Permission denied (publickey,gssapi-keyex,gssapi-with-mic 查看服务器sshd状态: text sshd[13132]: Authentication refused: bad ownership or modes for directory /home/tignioj/.ssh 原因是目录和文件权限不对，修改权限 text chmod 700 /home/tignioj/.ssh chmod 600 /home/tignioj/.ssh/authorized_keys 修改前： text drwxrwxr-x 2 tignioj tignioj 4096 Dec 31 04:34 .ssh 修改后： text drwx------ 2 tignioj tignioj 4096 Dec 31 04:34 .ssh 参考： https://www.cnblogs.com/my-first-blog-lgz/p/16385745.html https://blog.csdn.net/weixin_43693967/article/details/130789425 ","date":"2023-12-13","objectID":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/:6:0","series":null,"tags":["ssh"],"title":"ssh公钥登录禁root和密码登录并配置新用户","uri":"/ssh%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95%E7%A6%81root%E5%92%8C%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%B9%B6%E9%85%8D%E7%BD%AE%E6%96%B0%E7%94%A8%E6%88%B7/#错误排查"},{"categories":["软件折腾","Obsidian"],"content":"在这个教程中，你将： 生成站点 添加文档 配置站点 发布文档 注意，官方文档表示Windows用户不能用powershell执行以下命令，但是我用powershell大部分步骤都是没问题的，有问题的步骤会特别指出。 ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:0:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#"},{"categories":["软件折腾","Obsidian"],"content":" 7 初始化站点随便建立一个目录，用终端打开后输入hugo new site quickstart，就会生成一个文件夹quickstart powershell PS C:\\Users\\pcvmm\\Desktop\\data\\blog\u003e hugo new site quickstart Congratulations! Your new Hugo site was created in C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart. Just a few more steps... 1. Change the current directory to C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart. 2. Create or install a theme: - Create a new theme with the command \"hugo new theme \u003cTHEMENAME\u003e\" - Install a theme from https://themes.gohugo.io/ 3. Edit hugo.toml, setting the \"theme\" property to the theme name. 4. Create new content with the command \"hugo new content \u003cSECTIONNAME\u003e\\\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 5. Start the embedded web server with the command \"hugo server --buildDrafts\". See documentation at https://gohugo.io/. PS C:\\Users\\pcvmm\\Desktop\\data\\blog\u003e 生成quickstart时，hugo甚至还贴心的给出了接下来的步骤。 我们命令行先进入终端 cd quickstart，发现其目录结构如下 每个目录的详细信息请查看 Directory structure | Hugo (gohugo.io) 接着执行git仓库初始化 text git init # 执行git init对站点进行git仓库初始化以便于我们添加主题模块 ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:1:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#初始化站点"},{"categories":["软件折腾","Obsidian"],"content":" 8 下载主题模块 如果发现连不上github，就在终端用代理 $Env:http_proxy=“http://127.0.0.1:7890”;$Env:https_proxy=“http://127.0.0.1:7890” text git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:2:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#下载主题模块"},{"categories":["软件折腾","Obsidian"],"content":" 9 配置文件中启用主题官网的命令是 echo \"theme = 'ananke'\" \u003e\u003e hugo.toml,但是powershell不能这样执行，实际上这句命令意思就是往hugo.toml 最后一行追加 theme = ‘ananke’，也就是给站点指定主题。我们用vscode编辑这个文件。 hugo.toml text baseURL = 'https://example.org/' languageCode = 'en-us' title = 'My New Hugo Site' theme = 'ananke' # 指定主题 日志如下 powershell PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e git init Initialized empty Git repository in C:/Users/pcvmm/Desktop/data/blog/quickstart/.git/ PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e $Env:http_proxy=\"http://127.0.0.1:7890\";$Env:https_proxy=\"http://127.0.0.1:7890\" PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke Cloning into 'C:/Users/pcvmm/Desktop/data/blog/quickstart/themes/ananke'... remote: Enumerating objects: 2659, done. remote: Counting objects: 100% (88/88), done. remote: Compressing objects: 100% (53/53), done. remote: Total 2659 (delta 38), reused 64 (delta 28), pack-reused 2571 Receiving objects: 100% (2659/2659), 4.51 MiB | 338.00 KiB/s, done. Resolving deltas: 100% (1471/1471), done. warning: in the working copy of '.gitmodules', LF will be replaced by CRLF the next time Git touches it PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:3:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#配置文件中启用主题"},{"categories":["软件折腾","Obsidian"],"content":" 10 启动服务 text hugo server 此时就可以打开 http://localhost:1313 查看页面了。 ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:4:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#启动服务"},{"categories":["软件折腾","Obsidian"],"content":" 11 创建第一篇帖子先按下Ctrl + C 停止服务器，在网站根目录下输入 hugo new content posts/helloworld.md powershell PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e hugo new content posts/helloworld.md Content \"C:\\\\Users\\\\pcvmm\\\\Desktop\\\\data\\\\blog\\\\quickstart\\\\content\\\\posts\\\\helloworld.md\" created PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e 会发现content/posts/下自动生成了helloworld.md的文件，其中包括的内容如下 text +++ title = 'Helloworld' date = 2023-11-10T21:19:57+08:00 draft = true +++ +++里面是文档的信息，包括 title : 标题 date：创建日期 draft：草稿 更多文档属性请看 Front matter | Hugo (gohugo.io) 这时候我们就可以在这个md文件上书写了。 text +++ title = 'Helloworld' date = 2023-11-10T21:19:57+08:00 draft = true +++ # 你好 世界！ 再次启动服务器，为了构建这篇文章，我们还要加上-D参数 运行 hugo server -D text PS C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\u003e hugo server -D Watching for changes in C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\\{archetypes,assets,content,data,i18n,layouts,static,themes} Watching for config changes in C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\\hugo.toml, C:\\Users\\pcvmm\\Desktop\\data\\blog\\quickstart\\themes\\ananke\\config.yaml Start building sites … hugo v0.120.4-f11bca5fec2ebb3a02727fb2a5cfb08da96fd9df+extended windows/amd64 BuildDate=2023-11-08T11:18:07Z VendorInfo=gohugoio | EN -------------------+----- Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Built in 115 ms Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:5:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#创建第一篇帖子"},{"categories":["软件折腾","Obsidian"],"content":" 12 查看第一篇帖子打开localhost:1313，看到我们的新文档已经生成 点进去一看，非常完美 参考： https://gohugo.io/getting-started/quick-start/ ","date":"2023-11-10","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/:6:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（二）快速建站","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/#查看第一篇帖子"},{"categories":["软件折腾","Obsidian"],"content":"安装obsidian,git,hugo,vscode","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"},{"categories":["软件折腾","Obsidian"],"content":" 1 安装hugo（静态博客生成程序） https://github.com/gohugoio/hugo/releases/tag/v0.120.4 ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:1:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#安装hugo静态博客生成程序"},{"categories":["软件折腾","Obsidian"],"content":" 1.1 配置hugo环境变量为什么要配置环境变量？配置的原因是使得这个二进制文件可以在终端任意地方执行，如果你不配置环境变量，那么终端只能在软件所在目录下执行该程序。 下载完成hugo之后，解压，找到hugo.exe目录所在的位置，复制上面的路径，例如我把它解压到了 C:\\Users\\pcvmm\\Desktop\\software\\mybin\\hugo_extended_0.120.4_windows-amd64 打开环境变量。此电脑右键-\u003e属性-\u003e高级系统设置-\u003e环境变量 双击Path，新建，然后粘贴 依次确定，环境变量窗口也点确定并关闭 ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:1:1","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#配置hugo环境变量"},{"categories":["软件折腾","Obsidian"],"content":" 1.2 验证hugo是否安装完成打开终端（如果已经打开终端，需要重启终端） 输入hugo version ，显示版本号则成功配置。 powershell PS C:\\Users\\pcvmm\u003e hugo version hugo v0.120.4-f11bca5fec2ebb3a02727fb2a5cfb08da96fd9df+extended windows/amd64 BuildDate=2023-11-08T11:18:07Z VendorInfo=gohugoio PS C:\\Users\\pcvmm\u003e ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:1:2","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#验证hugo是否安装完成"},{"categories":["软件折腾","Obsidian"],"content":" 2 安装git（版本管理以及博客发布工具） https://git-scm.com/downloads 默认配置就行 选项虽然非常多，全部默认选项一直点Next就可以，其实不用搞这么复杂的。安装好后，你会发现git自动帮我们添加了git.exe的环境变量。也就是说即便你不用安装包的方式安装，而是下载的便携版的压缩包，解压之后仍然能够通过自己添加环境变量方式安装git ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:2:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#安装git版本管理以及博客发布工具"},{"categories":["软件折腾","Obsidian"],"content":" 2.1 验证git是否安装完成重启终端输入git version ,x显示版本号则表明安装成功 powershell PS C:\\Users\\pcvmm\u003e git version git version 2.42.0.windows.2 ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:2:1","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#验证git是否安装完成"},{"categories":["软件折腾","Obsidian"],"content":" 3 安装obsidian（文章管理、md编辑器） https://obsidian.md/download 下载好后，直接打开即可 ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:3:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#安装obsidian文章管理md编辑器"},{"categories":["软件折腾","Obsidian"],"content":" 4 安装Vscode（博客配置修改器）官网下载后安装即可 https://code.visualstudio.com/docs/?dv=win64user ","date":"2023-11-09","objectID":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/:4:0","series":["利用obsidian从零开始搭建hugo博客"],"tags":["hugo","obsidian"],"title":"obsidian从零开始搭建hugo博客（一）环境安装","uri":"/obsidian%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2%E4%B8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/#安装vscode博客配置修改器"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 问题由于obsidian中插入的链接都是以文件名称作为显示，而hugo博客大部分页面都是index.zh-cn.md，真正的名称保存在front-matter以及父类名称里面。那么带来的问题就是所有插入的链接显示都是 index.zh-cn.md而不是真正的名称。 例如 [index.zh-cn](../../用obsidian管理hugo文章小技巧/index.zh-cn.md), 显示效果就是 index.zh-cn，但是实际上我们想要显示的名称是用obsidian管理hugo文章小技巧。 为了解决这个问题，我想到了两个办法。 ","date":"2023-11-09","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":["obsidian插件","obsidian"],"title":"obsidian插件开发-链接的显示问题","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/#问题"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 1 在插入链接的时候，修改链接标题obsidian按下[[时，会弹窗让你选择你要插入的文件，这个弹窗类对象我不清除具体是什么对象，但是参阅官方文档知道这是一个SuggestModal相关的窗口 js export abstract class SuggestModal\u003cT\u003e extends Modal implements ISuggestOwner\u003cT\u003e { 可以看到SuggestModal实现了ISuggestOwner接口，点进去看发现ISuggestOwner有两个方法, 在注释中我们可以看到 selectSuggestion 会在做出选择的时候被调用，也就是说我们插入链接的时候，这个方法就会被调用。 js export interface ISuggestOwner\u003cT\u003e { /** * Render the suggestion item into DOM. * @public */ renderSuggestion(value: T, el: HTMLElement): void; /** * Called when the user makes a selection. * @public */ selectSuggestion(value: T, evt: MouseEvent | KeyboardEvent): void; } 但是知道这个有什么用呢？对我们插入链接有什么帮助？当然有用！ 知道了什么方法被调用意味我们可以偷天换日！把原本调用的方法换成我们自己的！ ","date":"2023-11-09","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["obsidian插件","obsidian"],"title":"obsidian插件开发-链接的显示问题","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/#在插入链接的时候修改链接标题"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 1.1 js最基础的函数替换方法js有个神奇的 apply()函数，它能够做到在不修改源函数的情况下处理参数。例如 js const obj = { // obj1对象里面打印参数1 fun1 : (arg1)=\u003e{ console.log(arg1); } } const origin_fun = obj.fun1; // 先拿到原始的函数fun1 // 修改成我们自己的方法 obj.fun1 = function (arg1) { // 处理参数 arg1 = arg1 + \", world!\" // 调用原始方法, 第一个参数是调用的对象，后面是原始函数的参数，要用数组形式传进去 origin_fun.apply(obj, [arg1]) } // 此时调用对象的方法 obj.fun1(\"hello\") // 输出hello, world! 对于selectSuggestion，里面有两个参数，一个是泛型T, 一个是MouseEvent，我们就可以写成下面这样 js // 先拿到原始的函数selectSuggestion let orig_fn = this.app.workspace.editorSuggest.suggests[0].selectSuggestion; // 再替换成我们自定义的函数 this.app.workspace.editorSuggest.suggests[0].selectSuggestion = function (value, evt) { console.log(value);// 处理参数 // 调用原始函数，并传入原本需要的参数（数组形式传入） orig_fn.apply(this, [value, evt]); } 为什么selectSuggestion 藏的这么深？obsidian官方文档中我没有查询到任何有关如何获取的方法，而是在社区论坛求助中得到了这位网友的指点 https://forum-zh.obsidian.md/t/topic/25546/6 ","date":"2023-11-09","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:1:1","series":null,"tags":["obsidian插件","obsidian"],"title":"obsidian插件开发-链接的显示问题","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/#js最基础的函数替换方法"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 2 不修改标题，而是修改显示效果（仅阅读模式生效）官方示例 https://docs.obsidian.md/Plugins/Editor/Markdown+post+processing 点击右上角的书本图标进入阅读模式，通过Ctrl + I 找到链接的dom，发现链接里面是这样的 html \u003ca class=\"internal-link\" data-href=\"../../../编程/Linux2/Ubuntu/Ubuntu安装Samba/index.zh-cn.md\" href=\"../../../编程/Linux2/Ubuntu/Ubuntu安装Samba/index.zh-cn.md\" target=\"_blank\" rel=\"noopener\"\u003eindex.zh-cn\u003c/a\u003e 我们可以根据internal-link获取到a标签，然后把标签的值设置成data-href里面文档的名称。 可以看到data-href中指向的目录为../../../编程/Linux2/Ubuntu/Ubuntu安装Samba/index.zh-cn.md ，利用正则表达式就可以提取标题。这里用到了组匹配。 .*\\/ 对应了 ../../../编程/Linux2/Ubuntu/ ，因为没有加问好，所以会贪婪匹配 (.*) 对应了Ubuntu安装Samba的内容 \\/index.zh-cn.md 对应了/index.zh-cn.md，其中/用了反义符号 写成代码就是 js this.registerMarkdownPostProcessor( (element, context) =\u003e { const links = element.findAll(\".internal-link\") for(const link of links) { const s=link.getAttribute(\"data-href\") if (s) { const ns = s.replace(/.*\\/(.*)\\/index.zh-cn.md/g, \"$1\") link.setText(ns) } } }); ","date":"2023-11-09","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["obsidian插件","obsidian"],"title":"obsidian插件开发-链接的显示问题","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/#不修改标题而是修改显示效果仅阅读模式生效"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 总结 第一种方法虽然能够利用suggestion来替换标题，但是只能在首次插入的时候替换，当我们在obsidian中修改文档标题名称时候，并不会再次触发suggestion引发修改（路径会修改，但是标题不会，因为修改的方法是在suggestion中定义的），因此有一定的弊端。 第二种方法只能在阅读模式下生效，我们发布文档到hugo之后仍然显示的是index.zh-cn.md，除非手动修改hugo的渲染方式render-link.html ","date":"2023-11-09","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":["obsidian插件","obsidian"],"title":"obsidian插件开发-链接的显示问题","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/#总结"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":"obsidian插件开发之文件操作","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":"将要操作的文件目录结构如图所示 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 4 一、文件操作","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#一文件操作"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 4.1 创建文件 js /** * @public */ create(path: string, data: string, options?: DataWriteOptions): Promise\u003cTFile\u003e; 示例：在仓库根目录创建1.md，内容为hello js this.app.vault.create(\"1.md\", \"hello\"); 示例：在仓库根的demo目录创建ok.md，内容为world 注意：目录不存在会报错 js this.app.vault.create(\"demo/ok.md\", \"hello\"); ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#创建文件"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 4.2 重命名文件调用fileManager可以让obsidian自动更新里面的链接！ js export class FileManager { /** * Rename or move a file safely, and update all links to it depending on the user's preferences. * @param file - the file to rename * @param newPath - the new path for the file * @public */ renameFile(file: TAbstractFile, newPath: string): Promise\u003cvoid\u003e; } 示例：修改 仓库根目录下的1.md为2.md js const f = this.app.vault.getAbstractFileByPath(\"1.md\") this.app.fileManager.renameFile(f, \"2.md\") 如果仅仅修改文件名称可以调用this.app.vault.rename()方法 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#重命名文件"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 4.3 获取所有文件 js /** * @public */ getFiles(): TFile[]; 示例：获取所有文件 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:3","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#获取所有文件"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 4.4 获取指定目录的文件列表 js /** * @public */ getAbstractFileByPath(path: string): TAbstractFile | null; 示例：获取posts下的所有文件 TAbstractFile虽然没有children这个属性，但是却能够调用，很奇怪? js this.app.vault.getAbstractFileByPath(\"content/posts\").children 这段代码在obsidian的控制台上可以直接运行，然而当我们调用npm run build 的时候却报错了. 经过查阅源码得知，TAbstractFile确实没有children属性，但是在运行过程中，控制台自动转换成了 TFolder对象，所以没有报错。 然而编译的时候却难以确定到底是TFolder还是TFile，因此我们需要手动强转成TFolder 强转的语法是在变量前面加上尖括号指定类型名称: ``\u003c类型\u003eobj` TAbstractFile是一个抽象类 js export abstract class TAbstractFile { vault: Vault; path: string; name: string; parent: TFolder; } TFile也继承于`TAbstractFile js export class TFile extends TAbstractFile { stat: FileStats; basename: string; extension: string; } TFolder也继承于`TAbstractFile js export class TFolder extends TAbstractFile { children: TAbstractFile[]; isRoot(): boolean; } TFile和TFolder都继承于TAbstractFile，因此他们都可以调用TAbstractFile的方法，同时拥有自己独特的方法，而children是TFolder独特的方法，因此我们需要将TAbstractFile转换成TFolder 示例：获取指定目录下的所有目录，封装成Series对象数组并返回 js interface Series { title: string; description: string; } /** ** @returns 获取系列，即content/series/下一级的所有目录名称。 */ getSeries() :Series[] { const p = this.app.vault?.getAbstractFileByPath(\"content/series\") console.log(p); // \u003cTFolder\u003e变量名，强制转换 const series = (\u003cTFolder\u003ethis.app.vault?.getAbstractFileByPath( \"content/series\"))?.children const arr = new Array\u003cSeries\u003e(); series.forEach((item : any) =\u003e { arr.push({title: item.name, description: item.name}) }); console.log(arr) return arr; } ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:4","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#获取指定目录的文件列表"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 5 二、文件夹操作","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#二文件夹操作"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 5.1 获取当前仓库系统目录 js this.app.vault.adapter.basePath ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:1","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#获取当前仓库系统目录"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 5.2 创建文件夹 js /** * @public */ createFolder(path: string): Promise\u003cvoid\u003e; 示例：在仓库根目录下创建名称为hello的文件夹 text this.app.vault.createFolder(\"hello\"); 结果： |仓库 |hello 示例：创建多层目录 text this.app.vault.createFolder(\"a/b/c\"); 结果： |仓库 |a |b |c ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:2","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#创建文件夹"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 6 结束语在开发过程中遇到各种问题，可以去官网 obsidian-api 查看源码obsidian-api/obsidian.d.ts 获取帮助 参考： Vault - Developer Documentation (obsidian.md) obsidian-api/obsidian.d.ts at bde556afa033e909ebfb9fcee8f5ef288276f78f · obsidianmd/obsidian-api (github.com) ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发-常用文件操作","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#结束语"},{"categories":["软件折腾","Obsidian"],"content":"obsidian管理hugo文章的一些技巧","date":"2023-11-05","objectID":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/","series":null,"tags":["obsidian","shell-command","hugo"],"title":"用obsidian管理hugo文章小技巧","uri":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":["软件折腾","Obsidian"],"content":" 1 一、搜索技巧 举例：查找所有草稿，即查找所有markdown文件中，属性draft为true的帖子。obsidian提供了一个 [propertiees: value] 的方法，于是我们输入 [\"draft\": true]，于是显示出结果如下 但是由于hugo的文章的文件名不作为标题，如何显示标题呢？只需要加上title就可以，例如。 非常好用的小技巧！ ","date":"2023-11-05","objectID":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["obsidian","shell-command","hugo"],"title":"用obsidian管理hugo文章小技巧","uri":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/#一搜索技巧"},{"categories":["软件折腾","Obsidian"],"content":" 2 二、发布技巧使用shell commands插件一键发布文档到github 例如我们原本需要手动输入命令提交 shell git add content/posts/xxxx.md git commit -m \"xxx\" git push origin main 我们可以把这些命令放进一个按钮里面，点击就可以立马提交。 shell git add {{folder_path:relative}} git commit -m \"{{folder_name}}\" git push origin main 设置如下。 点击小齿轮，在General那里设置Alias别名 为了明确我们当前提交的文档，最好来个确认框。 首先找到Preactions，新建一个Prompts提示框。打开review shell command in prompt,表示预览当前命令 接着让刚刚创建的命令关联这个prompt，找到命令，先点击小齿轮 找到Preactions，选中我们刚刚创建的promot 然后我们通过快捷命令就可以发布文章了。打开文档后，按下快捷键Ctrl + p，弹出输入框，输入发布文档，点击它，就会弹出确认框 但是此时会发现没有输出，这是因为默认情况下，正常执行不输出，为了能看到提交的情况，我们打开输出。 点击命令对应的小齿轮，找到Output，在Output channel for stdout中选择Notification ballon。也就是说标准输出都会弹出一个小气球显示结果信息 于是我们再次执行代码后，成功输出了信息。 ","date":"2023-11-05","objectID":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["obsidian","shell-command","hugo"],"title":"用obsidian管理hugo文章小技巧","uri":"/%E7%94%A8obsidian%E7%AE%A1%E7%90%86hugo%E6%96%87%E7%AB%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/#二发布技巧"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" Obsidian介绍obsidian是一款支持本地存储以及多种方式云端同步的笔记软件，界面很简洁，本质上开箱即用。但是如果你想要实现更多功能，要么去插件市场找，如果没有找到合适的，那就一起来动手自己做一个插件吧！ ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#obsidian介绍"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 克隆插件样本到本地打开官网 https://github.com/obsidianmd/obsidian-sample-plugin 选择Create a new repository，这样你就会获得一份克隆 随便起一个名字 接着下载到本地 text https://github.com/tignioj/myobsplugins.git 把他放到obsidian插件目录中 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#克隆插件样本到本地"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 安装环境进入我们刚下载好的插件目录 text cd myobsplugins 安装依赖库 text npm i 运行 text npm run dev 此时打开obsidian我们就能看到插件了！ ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#安装环境"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 热加载Hot-reload为了避免频繁开关插件，官方推荐热加载的方式来开发我们的插件，此时我们要额外下载一个插件。 https://github.com/pjeby/hot-reload 安装方式同理，把他下载到插件目录，然后重启obsidian就能手动启用了 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#热加载hot-reload"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 编写代码用vscode打开插件目录，编辑插件根目录下的main.ts 导入组件 js import { Notice, Plugin } from \"obsidian\"; 找到 async onload() 方法，添加以下代码 js this.addRibbonIcon('dice', 'Greet', () =\u003e { new Notice('Hello, world!'); }); 这时候会看到编辑器左边多了一个小按钮，点击按钮就会弹出Hello world. 恭喜你成功入门。 ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#编写代码"},{"categories":["软件折腾","Obsidian","obsidian插件开发"],"content":" 参考官网 https://docs.obsidian.md/Home ","date":"2023-11-05","objectID":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/:0:0","series":["obsidian插件开发基础"],"tags":["obsidian","obsidian插件"],"title":"obsidian插件开发（一）入门","uri":"/obsidian%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%80%E5%85%A5%E9%97%A8/#参考官网"},{"categories":null,"content":" :(far fa-edit fa-fw): DoIt 是一个由 HEIGE-PCloud 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LoveIt 主题， LeaveIt 主题 和 KeepIt 主题。 ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#"},{"categories":null,"content":" 1 特性","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#特性"},{"categories":null,"content":" 1.1 性能和 SEO :(fas fa-rocket fa-fw): 性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分 :(fab fa-searchengin fa-fw): 使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化 :(fab fa-google fa-fw): 支持 Google Analytics :(far fa-chart-bar fa-fw): 支持 Fathom Analytics :(far fa-chart-bar fa-fw): 支持 百度统计 :(far fa-chart-bar fa-fw): 支持 Umami Analytics :(far fa-chart-bar fa-fw): 支持 Plausible Analytics :(fas fa-search fa-fw): 支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu) :(fas fa-tachometer-alt fa-fw): 支持所有第三方库的 CDN ","date":"2019-08-02","objectID":"/about/:1:1","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#性能和-seo"},{"categories":null,"content":" 1.2 外观和布局 :(fas fa-desktop):/:(fas fa-mobile): 响应式布局 :(fas fa-sun):/:(fas fa-moon): 浅色/深色 主题模式 :(fas fa-layer-group fa-fw): 全局一致的设计语言 :(fas fa-ellipsis-h fa-fw): 支持分页 :(far fa-list-alt fa-fw): 易用和自动展开的文章目录 :(fas fa-language fa-fw): 支持多语言和国际化 :(fab fa-css3-alt fa-fw): 美观的 CSS 动画 ","date":"2019-08-02","objectID":"/about/:1:2","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#外观和布局"},{"categories":null,"content":" 1.3 社交和评论系统 :(far fa-user fa-fw): 支持 Gravatar 头像 :(fas fa-user-circle fa-fw): 支持本地头像 :(far fa-id-card fa-fw): 支持多达 64 种社交链接 :(fas fa-share-square fa-fw): 支持多达 28 种网站分享 :(far fa-comment fa-fw): 支持 Disqus 评论系统 :(far fa-comment-dots fa-fw): 支持 Gitalk 评论系统 :(far fa-comment-alt fa-fw): 支持 Valine 评论系统 :(far fa-comment-alt fa-fw): 支持 Waline 评论系统 :(far fa-comments fa-fw): 支持 Facebook 评论系统 :(fas fa-comment fa-fw): 支持 Telegram comments 评论系统 :(fas fa-comment-dots fa-fw): 支持 Commento 评论系统 :(far fa-comment-alt fa-fw): 支持 Utterances 评论系统 :(far fa-comment-alt fa-fw): 支持 Twikoo 评论系统 :(far fa-comment-alt fa-fw): 支持 Vssue 评论系统 :(far fa-comment-alt fa-fw): 支持 Remark42 评论系统 :(far fa-comment-alt fa-fw): 支持 giscus 评论系统 :(far fa-comment-alt fa-fw): 支持 Artalk 评论系统 ","date":"2019-08-02","objectID":"/about/:1:3","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#社交和评论系统"},{"categories":null,"content":" 1.4 扩展功能 :(fas fa-search fa-fw): 支持基于 algolia 或 Fuse.js 的搜索 :(far fa-grin-tongue-wink fa-fw): 支持 Twemoji :(fas fa-code fa-fw): 支持代码高亮 :(far fa-copy fa-fw): 一键复制代码到剪贴板 :(far fa-images fa-fw): 支持基于 lightgallery.js 的图片画廊 :(fab fa-font-awesome fa-fw): 支持 Font Awesome 图标的扩展 Markdown 语法 :(far fa-sticky-note fa-fw): 支持上标注释的扩展 Markdown 语法 :(fas fa-percentage fa-fw): 支持分数的扩展 Markdown 语法 :(fas fa-square-root-alt fa-fw): 支持基于 $ \\KaTeX $ 的数学公式 :(fas fa-project-diagram fa-fw): 支持基于 mermaid 的图表 shortcode :(fas fa-chart-pie fa-fw): 支持基于 ECharts 的交互式数据可视化 shortcode :(fas fa-map-marked-alt fa-fw): 支持基于 Mapbox GL JS 的 Mapbox shortcode :(fas fa-music fa-fw): 支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode :(fas fa-video fa-fw): 支持 Bilibili 视频 shortcode :(far fa-bell fa-fw): 支持多种注释的 shortcode :(fas fa-align-left fa-fw): 支持自定义样式的 shortcode :(fab fa-js-square fa-fw): 支持自定义脚本的 shortcode :(fas fa-i-cursor fa-fw): 支持基于 TypeIt 的打字动画 shortcode :(fas fa-cookie-bite fa-fw): 支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:1:4","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#扩展功能"},{"categories":null,"content":" 2 许可协议DoIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 DoIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete.js algoliasearch Fuse.js object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine Waline Twikoo Vssue cookieconsent Remark42 ","date":"2019-08-02","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#许可协议"}]